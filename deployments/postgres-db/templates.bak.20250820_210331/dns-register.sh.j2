#!/bin/bash

# DNS Auto-Registration Script for Deployed Containers
# This script automatically registers the container's hostname with the CT101 DNS server

# Configuration
SERVICE_NAME="{{ service_hostname | default(app_name) }}"
DNS_SERVER="192.168.1.11"  # CT101 IP
KEY_FILE="/etc/bind-key.conf"
DOMAIN="proxmox.local"
LOG_FILE="/var/log/dns-register.log"

# Logging function
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

# Get current network info
get_network_info() {
    IP=$(ip route get 1 | awk '{print $7; exit}')
    HOSTNAME="${SERVICE_NAME}.${DOMAIN}"
    REVERSE_ZONE=$(echo $IP | awk -F. '{print $3"."$2"."$1".in-addr.arpa"}')
    REVERSE_HOST=$(echo $IP | awk -F. '{print $4}')
}

# Test DNS server connectivity
test_dns_connectivity() {
    if ! nc -z "$DNS_SERVER" 53 2>/dev/null; then
        log_message "ERROR: Cannot reach DNS server $DNS_SERVER:53"
        return 1
    fi
    return 0
}

# Register DNS records
register_dns() {
    get_network_info
    
    if ! test_dns_connectivity; then
        log_message "ERROR: DNS server not reachable, skipping registration"
        return 1
    fi
    
    log_message "Registering ${HOSTNAME} → ${IP}"
    
    # Update forward DNS record
    nsupdate -k ${KEY_FILE} << EOF
server ${DNS_SERVER}
zone ${DOMAIN}
update delete ${HOSTNAME} A
update add ${HOSTNAME} 300 A ${IP}
send
EOF

    if [ $? -eq 0 ]; then
        log_message "✅ Successfully registered forward DNS: ${HOSTNAME} → ${IP}"
    else
        log_message "❌ Failed to register forward DNS record"
        return 1
    fi

    # Update reverse DNS record
    nsupdate -k ${KEY_FILE} << EOF
server ${DNS_SERVER}
zone ${REVERSE_ZONE}
update delete ${REVERSE_HOST}.${REVERSE_ZONE} PTR
update add ${REVERSE_HOST}.${REVERSE_ZONE} 300 PTR ${HOSTNAME}
send
EOF

    if [ $? -eq 0 ]; then
        log_message "✅ Successfully registered reverse DNS: ${IP} → ${HOSTNAME}"
    else
        log_message "⚠️  Failed to register reverse DNS record (forward DNS still works)"
    fi

    # Test resolution
    if nslookup ${HOSTNAME} ${DNS_SERVER} > /dev/null 2>&1; then
        log_message "✅ DNS resolution test passed for ${HOSTNAME}"
        return 0
    else
        log_message "⚠️  DNS resolution test failed for ${HOSTNAME}"
        return 1
    fi
}

# Cleanup DNS records
cleanup_dns() {
    get_network_info
    
    if ! test_dns_connectivity; then
        log_message "WARNING: DNS server not reachable, cannot cleanup records"
        return 1
    fi
    
    log_message "Cleaning up DNS records for ${HOSTNAME}"
    
    # Remove forward DNS record
    nsupdate -k ${KEY_FILE} << EOF
server ${DNS_SERVER}
zone ${DOMAIN}
update delete ${HOSTNAME} A
send
EOF

    # Remove reverse DNS record
    nsupdate -k ${KEY_FILE} << EOF
server ${DNS_SERVER}
zone ${REVERSE_ZONE}
update delete ${REVERSE_HOST}.${REVERSE_ZONE} PTR
send
EOF

    log_message "✅ DNS cleanup completed for ${HOSTNAME}"
}

# Monitor and re-register periodically
monitor_and_register() {
    log_message "Starting DNS monitoring service for ${SERVICE_NAME}"
    
    # Initial registration
    if register_dns; then
        log_message "Initial DNS registration successful"
    else
        log_message "Initial DNS registration failed, will retry"
    fi
    
    # Fork to background for monitoring
    (
        # Monitor for IP changes and re-register every 5 minutes
        while true; do
            sleep 300  # 5 minutes
            
            get_network_info
            CURRENT_IP="$IP"
            
            # Check if IP has changed by testing current registration
            REGISTERED_IP=$(nslookup ${HOSTNAME} ${DNS_SERVER} 2>/dev/null | awk '/^Address: / { print $2 }' | tail -1)
            
            if [ "$REGISTERED_IP" != "$CURRENT_IP" ]; then
                log_message "IP change detected: $REGISTERED_IP → $CURRENT_IP, re-registering..."
                register_dns
            else
                # Periodic re-registration to refresh TTL
                register_dns > /dev/null 2>&1
            fi
        done
    ) &
    
    # Store the background process PID
    echo $! > /var/run/dns-register.pid
    log_message "DNS monitoring started in background (PID: $!)"
}

# Handle different actions
case "$1" in
    register)
        register_dns
        ;;
    cleanup)
        cleanup_dns
        ;;
    monitor)
        monitor_and_register
        ;;
    test)
        get_network_info
        log_message "Test mode - would register: ${HOSTNAME} → ${IP}"
        test_dns_connectivity && echo "DNS server connectivity: OK" || echo "DNS server connectivity: FAILED"
        ;;
    *)
        echo "Usage: $0 {register|cleanup|monitor|test}"
        echo ""
        echo "Commands:"
        echo "  register  - Register hostname once"
        echo "  cleanup   - Remove DNS records"
        echo "  monitor   - Continuous monitoring and re-registration"
        echo "  test      - Test configuration and connectivity"
        exit 1
        ;;
esac

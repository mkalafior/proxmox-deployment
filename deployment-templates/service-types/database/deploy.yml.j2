---
# Deployment playbook for {{ service_name }} database service
- name: Deploy {{ service_name }} to Proxmox VE
  hosts: localhost
  connection: local
  gather_facts: true
  vars_files:
    - group_vars/all.yml
  
  tasks:
    - name: Validate environment variables
      assert:
        that:
          - proxmox_host is defined and proxmox_host != ""
          - >
            (proxmox_token_id is defined and proxmox_token_id != "" and 
             proxmox_token_secret is defined and proxmox_token_secret != "") or
            (proxmox_user is defined and proxmox_user != "" and 
             proxmox_password is defined and proxmox_password != "")
        fail_msg: |
          Required Proxmox authentication must be configured.

    - name: Check for SSH public key
      stat:
        path: "{{ ssh_public_key_path }}"
      register: ssh_key_stat

    - name: Generate dedicated Proxmox SSH key if it doesn't exist
      openssh_keypair:
        path: "{{ ssh_public_key_path | replace('.pub', '') }}"
        type: ed25519
      when: not ssh_key_stat.stat.exists

    - name: Read SSH public key
      slurp:
        src: "{{ ssh_public_key_path }}"
      register: ssh_public_key_content

    - name: Create Proxmox container via API
      shell: |
        curl -k -X POST \
          -H "Authorization: PVEAPIToken={{ proxmox_token_id }}={{ proxmox_token_secret }}" \
          -H "Content-Type: application/x-www-form-urlencoded" \
          -d "vmid={{ vm_id }}&unprivileged=1&features=nesting%3D1&password={{ (lookup('password', '/tmp/vm_root_password chars=ascii_letters,digits length=16')) | urlencode }}&ssh-public-keys={{ ssh_public_key_content.content | b64decode | trim | urlencode }}&ostemplate={{ vm_os_template | urlencode }}&rootfs={{ (vm_storage ~ ':' ~ vm_disk_size) | urlencode }}&cores={{ vm_cores }}&memory={{ vm_memory }}&swap={{ vm_swap }}&net0={{ ('name=eth0,bridge=' ~ vm_network_bridge ~ ',firewall=1,ip=dhcp') | urlencode }}" \
          "https://{{ proxmox_host }}:8006/api2/json/nodes/{{ proxmox_node }}/lxc"
      register: proxmox_vm
      failed_when: false

    - name: Debug container creation response
      debug:
        var: proxmox_vm
        verbosity: 1

    - name: Check if container creation was successful
      fail:
        msg: |
          Container creation failed!

          API Response: {{ proxmox_vm.stdout | default('No response') }}
          Error Details: {{ proxmox_vm.stderr | default('No error details') }}
          Return Code: {{ proxmox_vm.rc | default('Unknown') }}

          Troubleshooting Tips:
          1. Check if OS template exists: {{ vm_os_template }}
          2. Verify Proxmox node name: {{ proxmox_node }}
          3. Ensure storage '{{ vm_storage }}' exists and has space
          4. Check API token permissions for VM creation
          5. Verify VM ID {{ vm_id }} is not already in use

          Run the debug script: ./tools/proxmox-debug.sh
      when: proxmox_vm.rc != 0 or (proxmox_vm.stdout | default('')) == '' or (proxmox_vm.stdout | from_json).data == null

    - name: Extract UPID from successful container creation
      set_fact:
        container_upid: "{{ (proxmox_vm.stdout | from_json).data }}"
      when: proxmox_vm.rc == 0 and (proxmox_vm.stdout | from_json).data is defined

    - name: Start the container (idempotent)
      uri:
        url: "https://{{ proxmox_host }}:8006/api2/json/nodes/{{ proxmox_node }}/lxc/{{ vm_id }}/status/start"
        method: POST
        headers:
          Authorization: "PVEAPIToken={{ proxmox_token_id }}={{ proxmox_token_secret }}"
        validate_certs: "{{ proxmox_api_validate_certs }}"
        status_code: [200, 500]
        timeout: 60
      register: start_result
      failed_when: false
      changed_when: "start_result.status == 200"

    # Progressive backoff attempts for slow PVE clusters (20, 30, 30, 60, 60)
    - name: Backoff attempt 1 - wait 20s
      pause:
        seconds: 20
      when: (container_ip | default('')) == ''

    - name: Query interfaces after attempt 1
      uri:
        url: "https://{{ proxmox_host }}:8006/api2/json/nodes/{{ proxmox_node }}/lxc/{{ vm_id }}/interfaces"
        method: GET
        headers:
          Authorization: "PVEAPIToken={{ proxmox_token_id }}={{ proxmox_token_secret }}"
        validate_certs: "{{ proxmox_api_validate_certs }}"
        return_content: yes
        status_code: [200, 401, 403, 500]
      register: container_interfaces_result
      failed_when: false
      when: (container_ip | default('')) == ''

    - name: Set container IP after attempt 1
      set_fact:
        container_ip: "{{ (eth0_interface.inet | default('')) | regex_replace('/.*$', '') }}"
      vars:
        eth0_interface: "{{ container_interfaces_result.json.data | selectattr('name', 'equalto', 'eth0') | first }}"
      when:
        - (container_ip | default('')) == ''
        - container_interfaces_result is defined
        - container_interfaces_result.json is defined
        - container_interfaces_result.json.data is defined
        - (container_interfaces_result.json.data | selectattr('name','equalto','eth0') | list | length) > 0

    - name: Backoff attempt 2 - wait 30s
      pause:
        seconds: 30
      when: (container_ip | default('')) == ''

    - name: Query interfaces after attempt 2
      uri:
        url: "https://{{ proxmox_host }}:8006/api2/json/nodes/{{ proxmox_node }}/lxc/{{ vm_id }}/interfaces"
        method: GET
        headers:
          Authorization: "PVEAPIToken={{ proxmox_token_id }}={{ proxmox_token_secret }}"
        validate_certs: "{{ proxmox_api_validate_certs }}"
        return_content: yes
        status_code: [200, 401, 403, 500]
      register: container_interfaces_result
      failed_when: false
      when: (container_ip | default('')) == ''

    - name: Set container IP after attempt 2
      set_fact:
        container_ip: "{{ (eth0_interface.inet | default('')) | regex_replace('/.*$', '') }}"
      vars:
        eth0_interface: "{{ container_interfaces_result.json.data | selectattr('name', 'equalto', 'eth0') | first }}"
      when:
        - (container_ip | default('')) == ''
        - container_interfaces_result is defined
        - container_interfaces_result.json is defined
        - container_interfaces_result.json.data is defined
        - (container_interfaces_result.json.data | selectattr('name','equalto','eth0') | list | length) > 0

    - name: Backoff attempt 3 - wait 30s
      pause:
        seconds: 30
      when: (container_ip | default('')) == ''

    - name: Query interfaces after attempt 3
      uri:
        url: "https://{{ proxmox_host }}:8006/api2/json/nodes/{{ proxmox_node }}/lxc/{{ vm_id }}/interfaces"
        method: GET
        headers:
          Authorization: "PVEAPIToken={{ proxmox_token_id }}={{ proxmox_token_secret }}"
        validate_certs: "{{ proxmox_api_validate_certs }}"
        return_content: yes
        status_code: [200, 401, 403, 500]
      register: container_interfaces_result
      failed_when: false
      when: (container_ip | default('')) == ''

    - name: Set container IP after attempt 3
      set_fact:
        container_ip: "{{ (eth0_interface.inet | default('')) | regex_replace('/.*$', '') }}"
      vars:
        eth0_interface: "{{ container_interfaces_result.json.data | selectattr('name', 'equalto', 'eth0') | first }}"
      when:
        - (container_ip | default('')) == ''
        - container_interfaces_result is defined
        - container_interfaces_result.json is defined
        - container_interfaces_result.json.data is defined
        - (container_interfaces_result.json.data | selectattr('name','equalto','eth0') | list | length) > 0

    - name: Backoff attempt 4 - wait 60s
      pause:
        seconds: 60
      when: (container_ip | default('')) == ''

    - name: Query interfaces after attempt 4
      uri:
        url: "https://{{ proxmox_host }}:8006/api2/json/nodes/{{ proxmox_node }}/lxc/{{ vm_id }}/interfaces"
        method: GET
        headers:
          Authorization: "PVEAPIToken={{ proxmox_token_id }}={{ proxmox_token_secret }}"
        validate_certs: "{{ proxmox_api_validate_certs }}"
        return_content: yes
        status_code: [200, 401, 403, 500]
      register: container_interfaces_result
      failed_when: false
      when: (container_ip | default('')) == ''

    - name: Set container IP after attempt 4
      set_fact:
        container_ip: "{{ (eth0_interface.inet | default('')) | regex_replace('/.*$', '') }}"
      vars:
        eth0_interface: "{{ container_interfaces_result.json.data | selectattr('name', 'equalto', 'eth0') | first }}"
      when:
        - (container_ip | default('')) == ''
        - container_interfaces_result is defined
        - container_interfaces_result.json is defined
        - container_interfaces_result.json.data is defined
        - (container_interfaces_result.json.data | selectattr('name','equalto','eth0') | list | length) > 0

    - name: Backoff attempt 5 - wait 60s
      pause:
        seconds: 60
      when: (container_ip | default('')) == ''

    - name: Query interfaces after attempt 5
      uri:
        url: "https://{{ proxmox_host }}:8006/api2/json/nodes/{{ proxmox_node }}/lxc/{{ vm_id }}/interfaces"
        method: GET
        headers:
          Authorization: "PVEAPIToken={{ proxmox_token_id }}={{ proxmox_token_secret }}"
        validate_certs: "{{ proxmox_api_validate_certs }}"
        return_content: yes
        status_code: [200, 401, 403, 500]
      register: container_interfaces_result
      failed_when: false
      when: (container_ip | default('')) == ''

    - name: Set container IP after attempt 5
      set_fact:
        container_ip: "{{ (eth0_interface.inet | default('')) | regex_replace('/.*$', '') }}"
      vars:
        eth0_interface: "{{ container_interfaces_result.json.data | selectattr('name', 'equalto', 'eth0') | first }}"
      when:
        - (container_ip | default('')) == ''
        - container_interfaces_result is defined
        - container_interfaces_result.json is defined
        - container_interfaces_result.json.data is defined
        - (container_interfaces_result.json.data | selectattr('name','equalto','eth0') | list | length) > 0

    - name: Extract container IP
      set_fact:
        container_ip: "{{ (eth0_interface.inet | default('')) | regex_replace('/.*$', '') }}"
      vars:
        eth0_interface: "{{ container_interfaces_result.json.data | selectattr('name', 'equalto', 'eth0') | first }}"
      when:
        - container_interfaces_result.json is defined
        - container_interfaces_result.json.data is defined

    - name: Fallback - get container IP via pct exec
      shell: |
        /usr/sbin/pct exec {{ vm_id }} -- sh -lc "ip -o -4 addr show dev eth0 | awk '{print \\$4}' | head -n1"
      register: pct_ip_result
      changed_when: false
      ignore_errors: true
      delegate_to: "{{ proxmox_host }}"
      environment:
        PATH: "/usr/sbin:/usr/bin:/bin:/sbin"
      when: container_ip is not defined or (container_ip | default('')) == ''

    - name: Set container_ip from pct fallback
      set_fact:
        container_ip: "{{ (pct_ip_result.stdout | default('')) | regex_replace('/.*$', '') }}"
      when:
        - pct_ip_result is defined
        - (container_ip | default('')) == ''

    - name: Fail if IP discovery failed
      fail:
        msg: "Could not determine container IP"
      when: container_ip is not defined or (container_ip | default('')) == ''

    - name: Wait for SSH to become available
      wait_for:
        host: "{{ container_ip }}"
        port: 22
        timeout: 60

    - name: Add container to dynamic inventory
      add_host:
        name: "{{ container_ip }}"
        groups: proxmox_containers
        ansible_host: "{{ container_ip }}"
        ansible_user: root
        ansible_ssh_private_key_file: "{{ ssh_public_key_path | replace('.pub', '') }}"

    - name: Save container IP locally for management scripts
      copy:
        content: "{{ container_ip }}\n"
        dest: "./vm_ip.txt"
        mode: "0644"

  handlers:
    - name: reload systemd
      systemd:
        daemon_reload: yes

- name: Configure container and deploy {{ service_name }} database
  hosts: proxmox_containers
  become: true
  vars_files:
    - group_vars/all.yml

  tasks:
    - name: Normalize db_type from runtime_variant if undefined
      set_fact:
        db_type: "{{ db_type | default(runtime_variant) | default('postgresql') }}"

    - name: Update apt cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Install base packages
      apt:
        name:
          - ufw
          - qemu-guest-agent
        state: present

    - name: Configure firewall
      ufw:
        rule: allow
        port: "{{ item }}"
      loop: "{{ allowed_ports }}"

    - name: Enable firewall
      ufw:
        state: enabled

    - name: Install PostgreSQL
      apt:
        name:
          - postgresql
          - postgresql-contrib
          - python3-psycopg2
        state: present
      when: db_type == 'postgresql'

    - name: Ensure PostgreSQL is running
      systemd:
        name: postgresql
        state: started
        enabled: yes
      when: db_type == 'postgresql'

    - name: Discover PostgreSQL config directory
      shell: |
        dirname $(readlink -f $(find /etc/postgresql -type f -name postgresql.conf | head -n1))
      register: pg_conf_dir
      changed_when: false
      when: db_type == 'postgresql'

    - name: Configure listen_addresses in postgresql.conf
      lineinfile:
        path: "{{ pg_conf_dir.stdout }}/postgresql.conf"
        regexp: "^#?listen_addresses\\s*=.*"
        line: "listen_addresses = '*'"
        backup: yes
      when: db_type == 'postgresql'

    - name: Configure PostgreSQL port in postgresql.conf
      lineinfile:
        path: "{{ pg_conf_dir.stdout }}/postgresql.conf"
        regexp: "^#?port\\s*=.*"
        line: "port = {{ app_port }}"
        backup: yes
      when: db_type == 'postgresql'

    - name: Ensure pg_hba allows remote connections
      blockinfile:
        path: "{{ pg_conf_dir.stdout }}/pg_hba.conf"
        marker: "# {mark} ANSIBLE MANAGED BLOCK - remote access"
        block: |
          host    all             all             0.0.0.0/0               md5
          host    all             all             ::/0                    md5
      when: db_type == 'postgresql'

    - name: Restart PostgreSQL to apply config
      systemd:
        name: postgresql
        state: restarted
      when: db_type == 'postgresql'

    - name: Wait for PostgreSQL to listen
      wait_for:
        host: 127.0.0.1
        port: "{{ app_port }}"
        timeout: 30
        state: started
      when: db_type == 'postgresql'

    - name: Initialize PostgreSQL database
      postgresql_db:
        name: "{{ db_name | default(service_name) }}"
        state: present
        port: "{{ app_port }}"
        login_unix_socket: "/var/run/postgresql"
      become_user: postgres
      when: db_type == 'postgresql'

    - name: Create PostgreSQL user
      postgresql_user:
        name: "{{ db_user | default(service_name) }}"
        password: "{{ db_password }}"
        state: present
        port: "{{ app_port }}"
        login_unix_socket: "/var/run/postgresql"
      become_user: postgres
      when: db_type == 'postgresql'

    - name: Grant ALL privileges on database to user
      community.postgresql.postgresql_privs:
        database: "{{ db_name | default(service_name) }}"
        type: database
        roles: "{{ db_user | default(service_name) }}"
        privs: ALL
        state: present
        port: "{{ app_port }}"
        login_unix_socket: "/var/run/postgresql"
      become_user: postgres
      when: db_type == 'postgresql'

    - name: Install MySQL
      apt:
        name:
          - mysql-server
          - python3-pymysql
        state: present
      when: db_type == 'mysql'

    - name: Ensure MySQL is running
      systemd:
        name: mysql
        state: started
        enabled: yes
      when: db_type == 'mysql'

    - name: Initialize MySQL database and user
      mysql_db:
        name: "{{ db_name | default(service_name) }}"
        state: present
      when: db_type == 'mysql'

    - name: Create MySQL user with privileges
      mysql_user:
        name: "{{ db_user | default(service_name) }}"
        password: "{{ db_password }}"
        priv: "{{ db_name | default(service_name) }}.*:ALL"
        host: "%"
        state: present
      when: db_type == 'mysql'

    - name: Install Redis
      apt:
        name: redis-server
        state: present
      when: db_type == 'redis'

    - name: Configure Redis to listen on all interfaces
      lineinfile:
        path: /etc/redis/redis.conf
        regexp: '^bind'
        line: 'bind 0.0.0.0'
      notify: restart redis
      when: db_type == 'redis'

    - name: Ensure Redis is running
      systemd:
        name: redis-server
        state: started
        enabled: yes
      when: db_type == 'redis'

    - name: Install MongoDB (apt repo)
      shell: |
        wget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc | apt-key add -
        echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/6.0 multiverse" | tee /etc/apt/sources.list.d/mongodb-org-6.0.list
        apt-get update
        apt-get install -y mongodb-org
      args:
        warn: false
      when: db_type == 'mongodb'

    - name: Ensure mongod is running
      systemd:
        name: mongod
        state: started
        enabled: yes
      when: db_type == 'mongodb'

  handlers:
    - name: restart redis
      systemd:
        name: redis-server
        state: restarted



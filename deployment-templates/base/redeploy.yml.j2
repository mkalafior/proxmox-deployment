---
# Code redeployment playbook for {{ service_name }}
# Focuses on code updates without VM provisioning
- name: Redeploy {{ service_name }} code
  hosts: localhost
  connection: local
  gather_facts: true
  vars_files:
    - ../global-config.yml
    - service-config.yml
  
  vars:
    # Secure temporary directory (replaces /tmp usage)
    secure_temp_dir: "{{ playbook_dir }}/../.secure_temp/{{ service_name }}_{{ ansible_date_time.epoch }}_{{ ansible_pid | default(9999) }}"
  
  tasks:
    - name: Create secure temporary directory
      file:
        path: "{{ secure_temp_dir }}"
        state: directory
        mode: '0700'
      become: false

    - name: Set secure temp directory as fact for other plays
      set_fact:
        shared_secure_temp_dir: "{{ secure_temp_dir }}"

    - name: Validate service configuration
      assert:
        that:
          - service_name is defined and service_name != ""
          - service_type is defined and service_type != ""
          - service_type in ['nodejs', 'python', 'golang', 'static', 'signal-api']
        fail_msg: |
          Invalid service configuration for redeployment.
          Service type '{{ service_type | default('undefined') }}' is not supported for code redeployment.
          Supported types: nodejs, python, golang, static, signal-api

    - name: Debug redeployment info
      debug:
        msg: |
          Code Redeployment for {{ service_name }}:
          - Service Type: {{ service_type }}
          - Local Path: {{ local_app_path }}
          - Target VM: {{ vm_name }} ({{ vm_id }})
          - App Port: {{ app_port }}

    - name: Check if VM exists and is running
      uri:
        url: "https://{{ proxmox_host }}:8006/api2/json/nodes/{{ proxmox_node }}/{{ container_type }}/{{ vm_id }}/status/current"
        method: GET
        headers:
          Authorization: "{{ 'PVEAPIToken=' + proxmox_token_id + '=' + proxmox_token_secret if (proxmox_token_id != '' and proxmox_token_secret != '') else omit }}"
        validate_certs: false
        status_code: [200]
      register: vm_status_check
      when: proxmox_token_id != '' and proxmox_token_secret != ''

    - name: Verify VM is running
      assert:
        that:
          - vm_status_check.json.data.status == "running"
        fail_msg: |
          VM {{ vm_name }} ({{ vm_id }}) is not running.
          Current status: {{ vm_status_check.json.data.status | default('unknown') }}
          Please start the VM before attempting redeployment.
      when: vm_status_check is defined

    - name: Get VM IP address
      uri:
        url: "https://{{ proxmox_host }}:8006/api2/json/nodes/{{ proxmox_node }}/{{ container_type }}/{{ vm_id }}/agent/network-get-interfaces"
        method: GET
        headers:
          Authorization: "{{ 'PVEAPIToken=' + proxmox_token_id + '=' + proxmox_token_secret if (proxmox_token_id != '' and proxmox_token_secret != '') else omit }}"
        validate_certs: false
        status_code: [200, 501]
      register: vm_network_info
      failed_when: false
      when: proxmox_token_id != '' and proxmox_token_secret != ''

    - name: Extract container IP
      set_fact:
        container_ip: "{{ vm_network_info.json.data.result | selectattr('name', 'match', '^eth0$') | map(attribute='ip-addresses') | first | selectattr('ip-address-type', 'equalto', 'ipv4') | map(attribute='ip-address') | first }}"
      when: vm_network_info is defined and vm_network_info.status == 200 and vm_network_info.json.data.result is defined

    - name: Fallback to DNS resolution if API unavailable
      set_fact:
        container_ip: "{{ service_hostname }}.{{ dns_domain }}"
      when: container_ip is not defined

    - name: Test SSH connectivity
      wait_for:
        host: "{{ container_ip }}"
        port: 22
        timeout: 10
      register: ssh_test
      failed_when: false

    - name: Fail if SSH is not accessible
      fail:
        msg: |
          Cannot connect to VM {{ vm_name }} at {{ container_ip }}:22
          Please verify the VM is running and SSH is accessible.
      when: ssh_test.failed

    - name: Add container to dynamic inventory
      add_host:
        name: "{{ container_ip }}"
        groups: proxmox_containers
        ansible_host: "{{ container_ip }}"
        ansible_user: root
        ansible_ssh_private_key_file: "{{ ssh_public_key_path | replace('.pub', '') }}"
        ansible_ssh_common_args: "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"

    - name: Detect local custom deployment script
      stat:
        path: "{{ playbook_dir }}/scripts/custom_script.sh"
      register: local_custom_script
      become: false

    - name: Copy custom deployment script to temporary location
      copy:
        src: "{{ playbook_dir }}/scripts/custom_script.sh"
        dest: "{{ secure_temp_dir }}/custom_script.sh"
        mode: '0755'
      when: hostvars['localhost']['local_custom_script'].stat.exists
      become: false

    - name: Create application tar archive on localhost
      shell: |
        cd {{ local_app_path }}
        # Check if .deployignore exists and build exclude options
        EXCLUDE_OPTS=""
        if [ -f .deployignore ]; then
          # Read .deployignore and convert to tar exclude options
          while IFS= read -r line || [ -n "$line" ]; do
            # Skip empty lines and comments
            if [[ -n "$line" && ! "$line" =~ ^[[:space:]]*# ]]; then
              # Remove leading/trailing whitespace
              line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              if [[ -n "$line" ]]; then
                EXCLUDE_OPTS="$EXCLUDE_OPTS --exclude='$line'"
              fi
            fi
          done < .deployignore
        else
          # Default exclusions if no .deployignore file
          EXCLUDE_OPTS="--exclude='node_modules' --exclude='.git' --exclude='deployment' --exclude='deployments' --exclude='*.log' --exclude='.env'"
        fi
        
        # Create tar with dynamic exclusions
        eval "tar $EXCLUDE_OPTS -czf {{ secure_temp_dir }}/redeploy.tar.gz ."
      become: false
      when: container_ip is defined

- name: Execute code redeployment on {{ service_name }}
  hosts: proxmox_containers
  become: true
  vars_files:
    - ../global-config.yml
    - service-config.yml
  
  vars:
    # Use shared secure temp directory from first play
    secure_temp_dir: "{{ hostvars['localhost']['shared_secure_temp_dir'] }}"
    # Fix Ansible remote_tmp warnings by using system /tmp
    ansible_remote_tmp: /tmp
  
  tasks:
    - name: Wait for system to be ready
      wait_for_connection:
        timeout: 30

    - name: Create secure temporary directory on remote
      file:
        path: "{{ secure_temp_dir }}"
        state: directory
        mode: '0700'

    - name: Check current service status
      systemd:
        name: "{{ app_service_name }}"
      register: current_service_status
      failed_when: false

    - name: Display current service status
      debug:
        msg: "Current service status: {{ current_service_status.status.ActiveState | default('unknown') }}"

    - name: Create backup directory
      file:
        path: "{{ app_dir }}-backup-{{ ansible_date_time.epoch }}"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0755'
      register: backup_dir

    - name: Backup current application
      shell: |
        if [ -d "{{ app_dir }}" ]; then
          cp -r {{ app_dir }}/* {{ backup_dir.path }}/
        fi
      failed_when: false

    - name: Stop application service
      systemd:
        name: "{{ app_service_name }}"
        state: stopped
      when: current_service_status.status.ActiveState == "active"

    - name: Copy and extract application files
      block:
        - name: Copy tar archive to container
          copy:
            src: "{{ secure_temp_dir }}/redeploy.tar.gz"
            dest: "{{ secure_temp_dir }}/redeploy.tar.gz"
            mode: '0644'

        - name: Extract application files
          unarchive:
            src: "{{ secure_temp_dir }}/redeploy.tar.gz"
            dest: "{{ app_dir }}"
            remote_src: yes
            owner: "{{ app_user }}"
            group: "{{ app_user }}"

        - name: Clean up tar files
          file:
            path: "{{ secure_temp_dir }}/redeploy.tar.gz"
            state: absent



    - name: Set ownership of application files
      file:
        path: "{{ app_dir }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        recurse: yes

    # SERVICE-SPECIFIC INJECTION POINT: Redeployment Tasks
    {% if service_redeploy_tasks is defined and service_redeploy_tasks %}
    {% include 'service-parts/redeploy_tasks.yml.j2' %}
    {% endif %}

    - name: Upload custom deployment script to container
      copy:
        src: "{{ secure_temp_dir }}/custom_script.sh"
        dest: "/opt/custom_script.sh"
        mode: '0755'
        owner: root
        group: root
      when: hostvars['localhost']['local_custom_script'].stat.exists

    - name: Run custom deployment script (service-specific hook)
      shell: "/opt/custom_script.sh"
      args:
        chdir: "{{ app_dir }}"
      become_user: "{{ app_user }}"
      environment:
        APP_DIR: "{{ app_dir }}"
        SERVICE_TYPE: "{{ service_type | default('') }}"
        NODEJS_RUNTIME: "{{ nodejs_runtime | default('') }}"
        APP_PORT: "{{ app_port | string }}"
        SERVICE_NAME: "{{ service_name }}"
      register: custom_script_result
      changed_when: false
      failed_when: false
      when: hostvars['localhost']['local_custom_script'].stat.exists

    - name: Show custom script output
      debug:
        var: custom_script_result.stdout_lines
      when: hostvars['localhost']['local_custom_script'].stat.exists

    - name: Update environment file
      template:
        src: env.j2
        dest: "{{ app_dir }}/.env"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0600'

    - name: Start application service
      systemd:
        name: "{{ app_service_name }}"
        state: started
        daemon_reload: yes

    - name: Wait for service to start
      pause:
        seconds: 3

    # SERVICE-SPECIFIC INJECTION POINT: Health Check
    {% if service_health_check is defined and service_health_check %}
    {% include 'service-parts/health_check.yml.j2' %}
    {% endif %}

    - name: Verify service is running
      systemd:
        name: "{{ app_service_name }}"
      register: final_service_status

    - name: Display redeployment result
      debug:
        msg: |
          Redeployment completed for {{ service_name }}:
          - Service Status: {{ final_service_status.status.ActiveState }}
          - Backup Location: {{ backup_dir.path }}
          - Health Check: {{ health_check_result.msg | default('Not performed') }}

    - name: Cleanup old backups (keep last 1)
      shell: |
        cd {{ app_dir | dirname }}
        ls -dt {{ service_name }}-backup-* 2>/dev/null | tail -n +2 | xargs rm -rf
      failed_when: false

  handlers:
    - name: rollback on failure
      block:
        - name: Stop failed service
          systemd:
            name: "{{ app_service_name }}"
            state: stopped
          failed_when: false

        - name: Restore from backup
          shell: |
            if [ -d "{{ backup_dir.path }}" ]; then
              rm -rf {{ app_dir }}/*
              cp -r {{ backup_dir.path }}/* {{ app_dir }}/
              chown -R {{ app_user }}:{{ app_user }} {{ app_dir }}
            fi
          failed_when: false

        - name: Start restored service
          systemd:
            name: "{{ app_service_name }}"
            state: started
          failed_when: false

        - name: Notify rollback
          debug:
            msg: "Rollback completed. Service restored from backup."

# Cleanup play - runs on localhost after redeployment completes
- name: Cleanup redeployment artifacts
  hosts: localhost
  connection: local
  gather_facts: false
  vars_files:
    - ../global-config.yml
    - service-config.yml
  
  vars:
    # Use shared secure temp directory from first play
    secure_temp_dir: "{{ hostvars['localhost']['shared_secure_temp_dir'] }}"
  
  tasks:
    - name: Clean up local tar file after redeployment
      file:
        path: "{{ secure_temp_dir }}/redeploy.tar.gz"
        state: absent
      become: false

    - name: Clean up temporary custom script
      file:
        path: "{{ secure_temp_dir }}/custom_script.sh"
        state: absent
      when: hostvars['localhost']['local_custom_script'].stat.exists
      become: false

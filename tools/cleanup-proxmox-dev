#!/bin/bash

set -euo pipefail

# Script to stop and remove all Proxmox containers with a specified project tag
# Usage: ./cleanup-proxmox-dev [TAG] [--dry-run] [--force]

DRY_RUN=false
FORCE=false
PROJECT_TAG="proxmox-dev"  # Default tag

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --force)
      FORCE=true
      shift
      ;;
    --help|-h)
      echo "Usage: $0 [TAG] [--dry-run] [--force]"
      echo ""
      echo "Stop and remove all Proxmox containers with the specified project tag"
      echo "Default tag: $PROJECT_TAG"
      echo ""
      echo "Options:"
      echo "  --dry-run    Show what would be done without actually doing it"
      echo "  --force      Skip all confirmation prompts"
      echo "  --help, -h   Show this help message"
      echo ""
      echo "Environment variables required:"
      echo "  PROXMOX_HOST      - Proxmox server hostname/IP"
      echo "  PROXMOX_NODE      - Proxmox node name (default: pve)"
      echo "  TOKEN_ID          - Proxmox API token ID"
      echo "  TOKEN_SECRET      - Proxmox API token secret"
      echo ""
      echo "Examples:"
      echo "  export PROXMOX_HOST=192.168.1.100"
      echo "  export TOKEN_ID=root@pam!deploy-token"
      echo "  export TOKEN_SECRET=your-secret-here"
      echo "  $0 proxmox-dev --dry-run    # Clean up containers with 'proxmox-dev' tag"
      echo "  $0 my-project --force       # Clean up containers with 'my-project' tag"
      echo "  $0 --dry-run                # Clean up containers with default tag"
      exit 0
      ;;
    --*)
      echo "Unknown option: $1"
      echo "Use --help for usage information"
      exit 1
      ;;
    *)
      # First non-option argument is the tag
      if [[ -z "${PROJECT_TAG_SET:-}" ]]; then
        PROJECT_TAG="$1"
        PROJECT_TAG_SET=true
        shift
      else
        echo "Unknown argument: $1"
        echo "Use --help for usage information"
        exit 1
      fi
      ;;
  esac
done

# Load environment variables from .env file if it exists
if [[ -f .env ]]; then
  echo "üìÑ Loading environment from .env file..."
  set -a
  source .env
  set +a
fi

# Validate required environment variables
PROXMOX_HOST="${PROXMOX_HOST:-}"
PROXMOX_NODE="${PROXMOX_NODE:-pve}"
TOKEN_ID="${TOKEN_ID:-}"
TOKEN_SECRET="${TOKEN_SECRET:-}"

if [[ -z "$PROXMOX_HOST" ]]; then
  echo "‚ùå Error: PROXMOX_HOST environment variable is required"
  exit 1
fi

if [[ -z "$TOKEN_ID" || -z "$TOKEN_SECRET" ]]; then
  echo "‚ùå Error: TOKEN_ID and TOKEN_SECRET environment variables are required"
  echo "   Set up API token authentication in Proxmox first"
  exit 1
fi

# Function to make Proxmox API calls
proxmox_api() {
  local method="$1"
  local endpoint="$2"
  local data="${3:-}"
  
  local curl_args=(
    -k
    -X "$method"
    -H "Authorization: PVEAPIToken=${TOKEN_ID}=${TOKEN_SECRET}"
    -H "Content-Type: application/x-www-form-urlencoded"
    --max-time 30
    --silent
    --show-error
  )
  
  if [[ -n "$data" ]]; then
    curl_args+=(-d "$data")
  fi
  
  curl "${curl_args[@]}" "https://${PROXMOX_HOST}:8006/api2/json${endpoint}"
}

# Function to get all nodes
get_all_nodes() {
  echo "üîç Fetching all nodes from Proxmox cluster..." >&2
  proxmox_api "GET" "/nodes"
}

# Function to list available nodes
list_available_nodes() {
  local nodes_json="$1"
  
  # Use jq to extract node names and status
  echo "$nodes_json" | jq -r '
    .data[] | 
    select(.type == "node") |
    "\(.node):\(.status):\(.uptime // 0)"
  '
}

# Function to get all containers from a specific node
get_containers_from_node() {
  local node="$1"
  proxmox_api "GET" "/nodes/${node}/lxc"
}

# Function to get all containers from all online nodes
get_all_containers_from_all_nodes() {
  local online_nodes=("$@")
  local all_containers_json='{"data":[]}'
  
  echo "üîç Fetching LXC containers from all online nodes..." >&2
  
  for node in "${online_nodes[@]}"; do
    echo "   üì° Checking node: $node" >&2
    
    local node_containers
    node_containers=$(get_containers_from_node "$node")
    
    if [[ $? -eq 0 ]] && echo "$node_containers" | jq . >/dev/null 2>&1; then
      # Add node information to each container
      local containers_with_node
      containers_with_node=$(echo "$node_containers" | jq --arg node "$node" '
        .data[] |= (. + {"source_node": $node})
      ')
      
      # Merge the containers
      all_containers_json=$(echo "$all_containers_json $containers_with_node" | jq -s '
        .[0].data += .[1].data | .[0]
      ')
      
      local count
      count=$(echo "$node_containers" | jq '.data | length')
      echo "      ‚úÖ Found $count LXC containers" >&2
    else
      echo "      ‚ö†Ô∏è  Failed to fetch LXC containers from node $node" >&2
    fi
  done
  
  echo "$all_containers_json"
}

# Function to filter containers by tag
filter_containers_by_tag() {
  local containers_json="$1"
  local tag="$2"
  
  # Use jq to filter containers that have the specified tag
  # Handle both comma and semicolon separated tags
  echo "$containers_json" | jq -r --arg tag "$tag" '
    .data[] | 
    select(.tags and (
      (.tags | split(",") | map(gsub("^\\s+|\\s+$";"")) | index($tag)) or
      (.tags | split(";") | map(gsub("^\\s+|\\s+$";"")) | index($tag))
    )) |
    "\(.vmid):\(.name):\(.status):\(.tags):\(.source_node // "unknown")"
  '
}

# Function to stop a container
stop_container() {
  local vmid="$1"
  local name="$2"
  local status="$3"
  local node="$4"
  
  if [[ "$status" == "running" ]]; then
    echo "‚èπÔ∏è  Stopping container $vmid ($name) on node $node..."
    if [[ "$DRY_RUN" == "false" ]]; then
      local result
      result=$(proxmox_api "POST" "/nodes/${node}/lxc/${vmid}/status/stop" 2>&1)
      if [[ $? -eq 0 ]]; then
        echo "   ‚úÖ Stop command sent successfully"
        # Wait a moment for the container to stop
        sleep 3
      else
        echo "   ‚ö†Ô∏è  Warning: Stop command may have failed: $result"
      fi
    else
      echo "   üîç [DRY RUN] Would stop container $vmid on node $node"
    fi
  else
    echo "‚è∏Ô∏è  Container $vmid ($name) is already $status"
  fi
}

# Function to remove a container
remove_container() {
  local vmid="$1"
  local name="$2"
  local node="$3"
  
  echo "üóëÔ∏è  Removing container $vmid ($name) from node $node..."
  if [[ "$DRY_RUN" == "false" ]]; then
    local result
    result=$(proxmox_api "DELETE" "/nodes/${node}/lxc/${vmid}" 2>&1)
    if [[ $? -eq 0 ]]; then
      echo "   ‚úÖ Container removed successfully"
    else
      echo "   ‚ùå Error removing container: $result"
      return 1
    fi
  else
    echo "   üîç [DRY RUN] Would remove container $vmid from node $node"
  fi
}

# Function to get all online nodes
get_online_nodes() {
  local nodes_response
  nodes_response=$(get_all_nodes)
  
  if [[ $? -ne 0 ]]; then
    echo "‚ö†Ô∏è  Warning: Failed to fetch nodes from Proxmox API, using default node '$PROXMOX_NODE'" >&2
    echo "$PROXMOX_NODE"
    return 0
  fi
  
  # Check if response is valid JSON
  if ! echo "$nodes_response" | jq . >/dev/null 2>&1; then
    echo "‚ö†Ô∏è  Warning: Invalid JSON response from nodes API, using default node '$PROXMOX_NODE'" >&2
    echo "$PROXMOX_NODE"
    return 0
  fi
  
  # Get available nodes
  local available_nodes
  available_nodes=$(list_available_nodes "$nodes_response")
  
  if [[ -z "$available_nodes" ]]; then
    echo "‚ö†Ô∏è  Warning: No nodes found, using default node '$PROXMOX_NODE'" >&2
    echo "$PROXMOX_NODE"
    return 0
  fi
  
  echo "üñ•Ô∏è  Available Proxmox nodes:" >&2
  echo "" >&2
  
  local online_nodes=()
  local default_found=false
  local default_online=false
  
  # Parse and display nodes, collect online ones
  while IFS=':' read -r node status uptime; do
    if [[ -n "$node" ]]; then
      local status_icon="‚ùå"
      local is_online=false
      if [[ "$status" == "online" ]]; then
        status_icon="‚úÖ"
        is_online=true
        online_nodes+=("$node")
      fi
      
      local default_marker=""
      if [[ "$node" == "$PROXMOX_NODE" ]]; then
        default_marker=" (default)"
        default_found=true
        if [[ "$is_online" == "true" ]]; then
          default_online=true
        fi
      fi
      
      echo "   $status_icon $node - Status: $status$default_marker" >&2
    fi
  done <<< "$available_nodes"
  
  echo "" >&2
  
  if [[ ${#online_nodes[@]} -eq 0 ]]; then
    echo "‚ùå Error: No online nodes found in cluster" >&2
    return 1
  fi
  
  if [[ "$default_found" == "true" && "$default_online" == "true" ]]; then
    echo "‚úÖ Default node '$PROXMOX_NODE' is online and will be included" >&2
  elif [[ "$default_found" == "true" ]]; then
    echo "‚ö†Ô∏è  Warning: Default node '$PROXMOX_NODE' is not online" >&2
  else
    echo "‚ö†Ô∏è  Warning: Default node '$PROXMOX_NODE' not found in cluster" >&2
  fi
  
  echo "üîç Will search containers across ${#online_nodes[@]} online node(s): ${online_nodes[*]}" >&2
  echo ""
  
  # Return the online nodes (space-separated)
  printf '%s\n' "${online_nodes[@]}"
}

# Main execution
main() {
  echo "üè∑Ô∏è  Proxmox Container Cleanup Script"
  echo "   Target tag: $PROJECT_TAG"
  echo "   Proxmox host: $PROXMOX_HOST"
  echo "   Mode: $([ "$DRY_RUN" == "true" ] && echo "DRY RUN" || echo "LIVE")"
  echo ""
  
  # Get all online nodes
  local online_nodes_output
  online_nodes_output=$(get_online_nodes)
  
  if [[ $? -ne 0 ]]; then
    exit 1
  fi
  
  # Convert output to array
  local online_nodes=()
  while IFS= read -r node; do
    if [[ -n "$node" ]]; then
      online_nodes+=("$node")
    fi
  done <<< "$online_nodes_output"
  
  if [[ ${#online_nodes[@]} -eq 0 ]]; then
    echo "‚ùå Error: No online nodes available"
    exit 1
  fi
  
  # Get all containers from all online nodes
  local containers_response
  containers_response=$(get_all_containers_from_all_nodes "${online_nodes[@]}")
  
  if [[ $? -ne 0 ]]; then
    echo "‚ùå Error: Failed to fetch containers from Proxmox API"
    echo "   Response: $containers_response"
    exit 1
  fi
  
  # Check if response is valid JSON
  if ! echo "$containers_response" | jq . >/dev/null 2>&1; then
    echo "‚ùå Error: Invalid JSON response from Proxmox API"
    echo "   Response: $containers_response"
    exit 1
  fi
  
  # Filter containers by tag
  local tagged_containers
  tagged_containers=$(filter_containers_by_tag "$containers_response" "$PROJECT_TAG")
  
  if [[ -z "$tagged_containers" ]]; then
    echo "‚úÖ No containers found with tag '$PROJECT_TAG'"
    exit 0
  fi
  
  echo "üìã Found containers with tag '$PROJECT_TAG':"
  echo ""
  
  local container_count=0
  local vmids=()
  local names=()
  local statuses=()
  local nodes=()
  
  # Parse and display containers
  while IFS=':' read -r vmid name status tags node; do
    if [[ -n "$vmid" ]]; then
      echo "   ‚Ä¢ VMID: $vmid | Name: $name | Status: $status | Node: $node | Tags: $tags"
      vmids+=("$vmid")
      names+=("$name")
      statuses+=("$status")
      nodes+=("$node")
      ((container_count++))
    fi
  done <<< "$tagged_containers"
  
  echo ""
  echo "üìä Total containers to process: $container_count"
  
  if [[ $container_count -eq 0 ]]; then
    echo "‚úÖ No containers to process"
    exit 0
  fi
  
  # Confirmation prompt (unless --force or --dry-run)
  if [[ "$FORCE" == "false" && "$DRY_RUN" == "false" ]]; then
    echo ""
    echo "‚ö†Ô∏è  WARNING: This will STOP and REMOVE all containers listed above!"
    echo "   This action cannot be undone."
    echo ""
    read -p "Are you sure you want to continue? (yes/no): " -r
    if [[ ! $REPLY =~ ^[Yy][Ee][Ss]$ ]]; then
      echo "‚ùå Operation cancelled by user"
      exit 0
    fi
  fi
  
  echo ""
  echo "üöÄ Starting cleanup process..."
  echo ""
  
  # Process each container
  local success_count=0
  local error_count=0
  local skipped_count=0
  
  for i in "${!vmids[@]}"; do
    local vmid="${vmids[$i]}"
    local name="${names[$i]}"
    local status="${statuses[$i]}"
    local node="${nodes[$i]}"
    
    echo "[$((i+1))/$container_count] Processing container $vmid ($name) on node $node..."
    
    # Ask for confirmation for each container (unless --force or --dry-run)
    if [[ "$FORCE" == "false" && "$DRY_RUN" == "false" ]]; then
      echo ""
      echo "‚ö†Ô∏è  About to STOP and REMOVE container:"
      echo "   ‚Ä¢ VMID: $vmid"
      echo "   ‚Ä¢ Name: $name" 
      echo "   ‚Ä¢ Status: $status"
      echo "   ‚Ä¢ Node: $node"
      echo ""
      read -p "Delete this container? (yes/no/quit): " -r
      case $REPLY in
        [Yy][Ee][Ss])
          echo "‚úÖ Proceeding with deletion..."
          ;;
        [Qq][Uu][Ii][Tt])
          echo "‚ùå Operation cancelled by user"
          exit 0
          ;;
        *)
          echo "‚è≠Ô∏è  Skipping container $vmid ($name)"
          ((skipped_count++))
          echo ""
          continue
          ;;
      esac
      echo ""
    fi
    
    # Stop the container first
    if stop_container "$vmid" "$name" "$status" "$node"; then
      # Then remove it
      if remove_container "$vmid" "$name" "$node"; then
        ((success_count++))
      else
        ((error_count++))
      fi
    else
      echo "   ‚ùå Failed to stop container, skipping removal"
      ((error_count++))
    fi
    
    echo ""
  done
  
  # Summary
  echo "üìä Cleanup Summary:"
  echo "   ‚úÖ Successfully processed: $success_count containers"
  if [[ $skipped_count -gt 0 ]]; then
    echo "   ‚è≠Ô∏è  Skipped: $skipped_count containers"
  fi
  if [[ $error_count -gt 0 ]]; then
    echo "   ‚ùå Errors encountered: $error_count containers"
  fi
  echo ""
  
  if [[ "$DRY_RUN" == "true" ]]; then
    echo "üîç This was a dry run. No actual changes were made."
    echo "   Run without --dry-run to perform the actual cleanup."
  else
    echo "‚úÖ Cleanup completed!"
  fi
}

# Check if jq is available
if ! command -v jq &> /dev/null; then
  echo "‚ùå Error: jq is required but not installed"
  echo "   Install with: brew install jq (macOS) or apt-get install jq (Ubuntu)"
  exit 1
fi

# Run main function
main "$@"

#!/bin/bash

set -euo pipefail

CMD="${1:-help}"
shift || true

# Check for --remote-templates flag
USE_REMOTE_TEMPLATES=false
if [[ "$CMD" == "--remote-templates" ]]; then
  USE_REMOTE_TEMPLATES=true
  CMD="${1:-help}"
  shift || true
fi

TEMPLATES_ROOT_DEFAULT="$HOME/.proxmox-deploy/templates"
PROJECT_ROOT_OVERRIDE="${PROJECT_ROOT_OVERRIDE:-$(pwd)}"

# Auto-detect if we're running from within the repository for development
detect_local_templates() {
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local repo_root="$(dirname "$script_dir")"
  
  # Check if we're in the proxmox-deploy-playground repository
  if [[ -f "$repo_root/deployment-templates/generators/generate.sh" ]]; then
    echo "$repo_root"
  else
    echo ""
  fi
}

# Determine templates root: use local if in repo, otherwise use default
LOCAL_REPO_ROOT="$(detect_local_templates)"
if [[ -n "$LOCAL_REPO_ROOT" && -z "${TEMPLATES_ROOT:-}" && "$USE_REMOTE_TEMPLATES" == "false" ]]; then
  TEMPLATES_ROOT="$LOCAL_REPO_ROOT"
  echo "üîß Using local templates from: $TEMPLATES_ROOT"
  echo "üìÅ Template source: Local repository (development mode)"
  echo "   - Base templates: $TEMPLATES_ROOT/deployment-templates/base/"
  echo "   - Service types: $TEMPLATES_ROOT/deployment-templates/service-types/"
  echo "   - Generators: $TEMPLATES_ROOT/deployment-templates/generators/"
else
  TEMPLATES_ROOT="${TEMPLATES_ROOT:-$TEMPLATES_ROOT_DEFAULT}"
  echo "üìÅ Template source: Remote/cached templates"
  echo "   - Templates root: $TEMPLATES_ROOT"
fi

# Helper: Auto-discover and load .env files
load_env_files() {
  local loaded_files=()
  
  # 1. Load global CLI environment (~/.pxdcli/env.global) if present
  PXDCLI_CONFIG_DIR="${PXDCLI_CONFIG_DIR:-$HOME/.pxdcli}"
  PXDCLI_GLOBAL_ENV="${PXDCLI_GLOBAL_ENV:-$PXDCLI_CONFIG_DIR/env.global}"
  if [[ -f "$PXDCLI_GLOBAL_ENV" ]]; then
    # shellcheck disable=SC1090
    . "$PXDCLI_GLOBAL_ENV"
    loaded_files+=("$PXDCLI_GLOBAL_ENV")
  fi
  
  # 2. Auto-discover .env files in current directory and parent directories
  local current_dir="$(pwd)"
  local search_dir="$current_dir"
  
  # Search up to 3 levels up for .env files
  for i in {1..3}; do
    if [[ -f "$search_dir/.env" ]]; then
      echo "üîß Loading environment from: $search_dir/.env"
      # shellcheck disable=SC1090
      set -a; . "$search_dir/.env"; set +a
      loaded_files+=("$search_dir/.env")
      break  # Stop at first .env file found
    fi
    
    # Move up one directory
    local parent_dir="$(dirname "$search_dir")"
    if [[ "$parent_dir" == "$search_dir" ]]; then
      break  # Reached root directory
    fi
    search_dir="$parent_dir"
  done
  
  # 3. Also check for project-specific .env in the proxmox-deploy root
  if [[ -f "$PROJECT_ROOT_OVERRIDE/.env" && "$PROJECT_ROOT_OVERRIDE/.env" != "$current_dir/.env" ]]; then
    echo "üîß Loading project environment from: $PROJECT_ROOT_OVERRIDE/.env"
    # shellcheck disable=SC1090
    set -a; . "$PROJECT_ROOT_OVERRIDE/.env"; set +a
    loaded_files+=("$PROJECT_ROOT_OVERRIDE/.env")
  fi
  
  # Show what was loaded
  if [[ ${#loaded_files[@]} -gt 0 ]]; then
    echo "‚úÖ Loaded environment from ${#loaded_files[@]} file(s):"
    printf "   - %s\n" "${loaded_files[@]}"
  else
    echo "‚ÑπÔ∏è  No .env files found - using shell environment variables"
  fi
}

# Load environment files automatically
load_env_files

# Vault management functions
VAULT_DIR="$PROJECT_ROOT_OVERRIDE/vault"
SSH_KEY_PATH="$HOME/.ssh/proxmox_key"

# Initialize vault system if needed
init_vault_if_needed() {
  if [[ ! -d "$VAULT_DIR" || ! -f "$VAULT_DIR/.vault_password" || ! -f "$VAULT_DIR/vault.yml" ]]; then
    echo "üîí Initializing secure vault system..."
    init_vault_system
  fi
}

# Generate vault password from SSH key
generate_vault_password() {
  if [[ ! -f "$SSH_KEY_PATH" ]]; then
    echo "üîë Generating SSH key for vault security..."
    ssh-keygen -t ed25519 -f "$SSH_KEY_PATH" -N "" -C "proxmox-deploy-vault-$(date +%Y%m%d)"
  fi
  # Create deterministic password from SSH key
  ssh-keygen -f "$SSH_KEY_PATH" -y | sha256sum | cut -d' ' -f1
}

# Initialize vault system
init_vault_system() {
  mkdir -p "$VAULT_DIR"
  
  # Create vault password file
  local vault_password_file="$VAULT_DIR/.vault_password"
  generate_vault_password > "$vault_password_file"
  chmod 600 "$vault_password_file"
  
  # Create .gitignore for vault directory
  cat > "$VAULT_DIR/.gitignore" << 'EOF'
# Exclude vault password file (contains decryption key)
.vault_password

# Include encrypted vault files (safe to commit)
!*.vault
!vault.yml
EOF

  # Create main vault file
  local vault_file="$VAULT_DIR/vault.yml"
  if [[ ! -f "$vault_file" ]]; then
    local temp_vault_file="$VAULT_DIR/.vault_template_$$"
    cat > "$temp_vault_file" << 'EOF'
# Encrypted database passwords for Proxmox Deploy services
# This file contains Ansible Vault encrypted passwords
# Safe to commit to version control

vault_passwords: {}
EOF
    ansible-vault encrypt "$temp_vault_file" --vault-password-file "$vault_password_file" --encrypt-vault-id default
    mv "$temp_vault_file" "$vault_file"
  fi
  
  # Create/update ansible.cfg
  local ansible_cfg="$PROJECT_ROOT_OVERRIDE/ansible.cfg"
  if [[ ! -f "$ansible_cfg" ]]; then
    cat > "$ansible_cfg" << EOF
[defaults]
vault_password_file = vault/.vault_password
host_key_checking = False
stdout_callback = yaml
EOF
  else
    if ! grep -q "vault_password_file" "$ansible_cfg"; then
      echo "vault_password_file = vault/.vault_password" >> "$ansible_cfg"
    fi
  fi
  
  # Initialize secure temp directory
  mkdir -p "$PROJECT_ROOT_OVERRIDE/.secure_temp"
  chmod 700 "$PROJECT_ROOT_OVERRIDE/.secure_temp"
  cat > "$PROJECT_ROOT_OVERRIDE/.secure_temp/.gitignore" << 'EOF'
# Exclude all temporary files - they should never be committed
*
!.gitignore
EOF
  
  echo "‚úÖ Vault system initialized with SSH key: $SSH_KEY_PATH"
}

# Generate secure password
generate_secure_password() {
  local length=${1:-32}
  openssl rand -base64 $((length * 3 / 4)) | tr -d "=+/" | cut -c1-${length}
}

# Encrypt password for service
encrypt_service_password() {
  local service_name="$1"
  local password_type="${2:-db}"  # db or vm_root
  
  local vault_file="$VAULT_DIR/vault.yml"
  local vault_password_file="$VAULT_DIR/.vault_password"
  
  local password_key="$service_name"
  if [[ "$password_type" == "vm_root" ]]; then
    password_key="vm_root_$service_name"
  fi
  
  # Check if password already exists
  if ansible-vault view "$vault_file" --vault-password-file "$vault_password_file" 2>/dev/null | grep -q "^  ${password_key}:"; then
    echo "üîí Password for '$password_key' already exists in vault"
    return 0
  fi
  
  # Generate new password
  local new_password=$(generate_secure_password 32)
  
  # Decrypt, update, re-encrypt
  local temp_file="$VAULT_DIR/.temp_vault_$$_$(date +%s)"
  ansible-vault decrypt "$vault_file" --vault-password-file "$vault_password_file" --output "$temp_file"
  
  # Update YAML with Python
  python3 << EOF
import yaml
import sys

with open('$temp_file', 'r') as f:
    data = yaml.safe_load(f) or {}

if 'vault_passwords' not in data:
    data['vault_passwords'] = {}

data['vault_passwords']['$password_key'] = '$new_password'

with open('$temp_file', 'w') as f:
    yaml.dump(data, f, default_flow_style=False)
EOF
  
  ansible-vault encrypt "$temp_file" --vault-password-file "$vault_password_file" --encrypt-vault-id default
  mv "$temp_file" "$vault_file"
  
  echo "üîê Generated and encrypted password for: $password_key"
}

# Ensure service has required passwords
ensure_service_passwords() {
  local service_name="$1"
  local service_type="$2"
  
  init_vault_if_needed
  
  # For database services, ensure db password exists
  if [[ "$service_type" == "database" ]]; then
    encrypt_service_password "$service_name" "db"
  fi
  
  # For all services, ensure VM root password exists
  encrypt_service_password "$service_name" "vm_root"
}

ensure_templates() {
  # Skip git operations if using local templates from the repository
  if [[ -n "$LOCAL_REPO_ROOT" && "$TEMPLATES_ROOT" == "$LOCAL_REPO_ROOT" ]]; then
    echo "üìÅ Using local repository templates (development mode)"
    return 0
  fi
  
  # Standard behavior: clone or update remote templates
  if [[ ! -d "$TEMPLATES_ROOT/.git" ]]; then
    mkdir -p "$(dirname "$TEMPLATES_ROOT")"
    git clone --depth 1 https://github.com/mkalafior/proxmox-deploy-playground "$TEMPLATES_ROOT"
  else
    git -C "$TEMPLATES_ROOT" pull --ff-only || true
  fi
}

# Helper: extract key from YAML (simple key: value) without yq
yaml_get_key() {
  local file="$1"; shift; local key="$1"; shift
  [[ -f "$file" ]] || { echo ""; return 0; }
  grep -E "^${key}:" "$file" | head -n1 | awk -F: '{print $2}' | xargs || true
}

# Helper: determine FQDN for a service
service_fqdn() {
  local svc_dir="$1"; shift
  local config_file="$svc_dir/service-config.yml"
  local global_config="$(dirname "$svc_dir")/global-config.yml"
  local host="$(yaml_get_key "$config_file" "service_hostname")"
  local domain="$(yaml_get_key "$global_config" "dns_domain")"
  if [[ -n "$host" && -n "$domain" ]]; then
    echo "$host.$domain"
  else
    echo ""
  fi
}

# Helper: get VM IP via Proxmox API using node and VM_ID
service_ip_via_api() {
  local svc_dir="$1"; shift
  local config_file="$svc_dir/service-config.yml"
  local node="$(yaml_get_key "$config_file" "proxmox_node")"
  local vmid="$(yaml_get_key "$config_file" "vm_id")"
  if [[ -z "${PROXMOX_HOST:-}" || -z "${TOKEN_ID:-}" || -z "${TOKEN_SECRET:-}" || -z "$node" || -z "$vmid" ]]; then
    echo ""; return 0
  fi
  local url="https://${PROXMOX_HOST}:8006/api2/json/nodes/${node}/lxc/${vmid}/interfaces"
  local resp
  resp=$(curl -ks -H "Authorization: PVEAPIToken=${TOKEN_ID}=${TOKEN_SECRET}" "$url" 2>/dev/null || true)
  if command -v jq >/dev/null 2>&1; then
    echo "$resp" | jq -r '(
      .data[]? | select(.name=="eth0") |
      (.inet | if type=="array" then .[0] elif type=="string" then . else "" end)
    ) // ""' | sed 's#/.*$##' | head -n1
  else
    echo "$resp" | grep -o '"name":"eth0"[^{]*\{[^}]*\}' | grep -o '"inet":[^\]]*' | grep -Eo '"[0-9.]+/[0-9]+"' | head -n1 | tr -d '"' | sed 's#/.*$##'
  fi
}

# Helper: get VM status via Proxmox API (running/stopped)
service_status_via_api() {
  local svc_dir="$1"; shift
  local service_config="$svc_dir/service-config.yml"
  
  # Get values from service-config.yml
  local node=""
  local vmid=""
  if [[ -f "$service_config" ]]; then
    node=$(grep -E '^proxmox_node:' "$service_config" | awk -F: '{print $2}' | xargs || true)
    vmid=$(grep -E '^vm_id:' "$service_config" | awk -F: '{print $2}' | xargs || true)
  fi
  
  if [[ -z "${PROXMOX_HOST:-}" || -z "${TOKEN_ID:-}" || -z "${TOKEN_SECRET:-}" || -z "$node" || -z "$vmid" ]]; then
    echo ""; return 0
  fi
  
  local url="https://${PROXMOX_HOST}:8006/api2/json/nodes/${node}/lxc/${vmid}/status/current"
  local resp
  resp=$(curl -ks -H "Authorization: PVEAPIToken=${TOKEN_ID}=${TOKEN_SECRET}" "$url" 2>/dev/null || true)
  if command -v jq >/dev/null 2>&1; then
    echo "$resp" | jq -r '.data.status // empty'
  else
    echo "$resp" | grep -o '"status"\s*:\s*"[^"]\+"' | head -n1 | sed 's/.*:"\(.*\)"/\1/'
  fi
}

# Helper: determine which systemd unit(s) to check for a service
determine_units() {
  local svc_dir="$1"; shift
  local default_unit="$1"; shift || true
  local config_file="$svc_dir/service-config.yml"
  local units=""
  local service_type="$(yaml_get_key "$config_file" "service_type")"
  local app_service_name="$(yaml_get_key "$config_file" "app_service_name")"
  [[ -z "$app_service_name" ]] && app_service_name="$default_unit"

  if [[ "$service_type" == "database" ]]; then
    local db_type="$(yaml_get_key "$config_file" "db_type")"
    [[ -z "$db_type" ]] && db_type="$(yaml_get_key "$config_file" "runtime_variant")"
    case "$db_type" in
      postgresql|postgres)
        units="postgresql"
        ;;
      mysql|mariadb)
        units="mysql"
        ;;
      redis)
        units="redis-server"
        ;;
      mongodb|mongo)
        units="mongod"
        ;;
      *)
        units="postgresql mysql redis-server mongod"
        ;;
    esac
  elif [[ "$service_type" == "tor-proxy" ]]; then
    units="tor privoxy"
  else
    units="$app_service_name"
  fi

  echo "$units"
}

usage() {
  echo "pxdcli [--remote-templates] <command> [args]"
  echo ""
  echo "Options:"
  echo "  --remote-templates                       # Force use of remote templates (skip local detection)"
  echo ""
  echo "Commands:"
  echo "  generate <service> --type <type> [opts]  # Generate service with command-line args"
  echo "  create <service>                         # Interactive service generation"
  echo "  update [options] [services...]           # Update deployment templates"
  echo "    --dry-run                            # Preview changes without applying"
  echo "    --force                              # Force update even if no changes"
  echo "    --no-backup                          # Skip backup creation"
  echo "    --type <type>                        # Update only specific service type"
  echo "    --file <file>                        # Update only specific template file"
  echo "  deploy <service>                         # Deploy single service"
  echo "  deploy-all                               # Deploy all services"
  echo "  redeploy <service> [--no-build] [--force] # Redeploy code for existing service"
  echo "  redeploy-all [--no-build] [--force]     # Redeploy all code-based services"
  echo "  cleanup <service>                        # Cleanup/destroy service"
  echo "  list                                     # List services under PROJECT_ROOT/deployments"
  echo "  status [service]                         # Show service status (hostname-based)"
  echo "  logs <service>                           # Show recent logs via SSH"
  echo "  restart <service>                        # Restart service unit via SSH"
  echo "  info <service>                           # Show service info (FQDN, IP, ports)"
  echo "  ssh <service>                            # SSH into service host"
  echo "  nodes                                    # List Proxmox nodes (requires TOKEN_ID/TOKEN_SECRET)"
  echo "  vault-init                               # Initialize vault system"
  echo "  vault-list                               # List encrypted passwords"
  echo "  vault-show <service> [type]              # Show password for service (type: db|vm_root)"
  echo "  vault-rotate <service> [type]            # Rotate password for service"
  echo "  vault-backup                             # Create backup of vault files"
  echo "  help"
}

case "$CMD" in
  generate)
    ensure_templates
    TEMPLATES_ROOT="$TEMPLATES_ROOT" PROJECT_ROOT_OVERRIDE="$PROJECT_ROOT_OVERRIDE" \
      bash "$TEMPLATES_ROOT/deployment-templates/generators/generate.sh" "$@"
    ;;
  create)
    # Interactive service generation (migrated from manage-services.sh)
    service_name="${1:-}"
    if [[ -z "$service_name" ]]; then
      echo "Usage: pxdcli create <service-name>"
      exit 1
    fi
    
    if [[ -d "$PROJECT_ROOT_OVERRIDE/deployments/$service_name" ]]; then
      echo "‚ö†Ô∏è  Service '$service_name' already exists"
      read -p "Overwrite existing service? (y/N): " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Generation cancelled"
        exit 0
      fi
    fi
    
    echo "üöÄ Creating new service: $service_name"
    echo "======================================"
    echo ""
    
    # Fetch and display available nodes first
    echo "üîç Fetching available Proxmox nodes..."
    if [[ -n "${PROXMOX_HOST:-}" && -n "${TOKEN_ID:-}" && -n "${TOKEN_SECRET:-}" ]]; then
      available_nodes=$(curl -ks -H "Authorization: PVEAPIToken=${TOKEN_ID}=${TOKEN_SECRET}" \
        "https://${PROXMOX_HOST}:8006/api2/json/nodes" 2>/dev/null | \
        python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    nodes = [node['node'] for node in data.get('data', [])]
    print(' '.join(nodes))
except:
    pass
" 2>/dev/null || echo "")
      
      if [[ -n "$available_nodes" ]]; then
        echo "üìã Available nodes: $available_nodes"
      else
        echo "‚ö†Ô∏è  Could not fetch nodes from API, you'll need to enter manually"
      fi
    else
      echo "‚ö†Ô∏è  No Proxmox credentials found, you'll need to enter node manually"
    fi
    echo ""
    
    # Interactive prompts
    read -p "Proxmox node name: " proxmox_node
    while [[ -z "$proxmox_node" ]]; do
      echo "Node name is required"
      read -p "Proxmox node name: " proxmox_node
    done
    
    read -p "Application port (e.g., 3003): " app_port
    while [[ ! "$app_port" =~ ^[0-9]+$ ]]; do
      echo "Port must be a number"
      read -p "Application port (e.g., 3003): " app_port
    done
    
    read -p "Cloudflare subdomain (optional, leave blank to disable): " app_subdomain
    read -p "Service hostname (optional, default: $service_name): " service_hostname
    service_hostname=${service_hostname:-$service_name}
    
    read -p "Service type (nodejs/python/golang/rust/database/static/tor-proxy): " service_type
    service_type=$(echo "$service_type" | tr '[:upper:]' '[:lower:]')
    
    runtime_variant=""
    if [[ "$service_type" == "nodejs" ]]; then
      read -p "Node runtime (node/bun) [bun]: " runtime_variant
      runtime_variant=${runtime_variant:-bun}
    elif [[ "$service_type" == "database" ]]; then
      read -p "Database type (postgresql/mysql/redis/mongodb) [postgresql]: " runtime_variant
      runtime_variant=${runtime_variant:-postgresql}
    fi
    
    # Build command
    cmd=("pxdcli" "generate" "$service_name" "--type" "$service_type" "--port" "$app_port" "--node" "$proxmox_node" "--hostname" "$service_hostname")
    if [[ -n "$runtime_variant" ]]; then
      cmd+=("--runtime" "$runtime_variant")
    fi
    if [[ -n "$app_subdomain" ]]; then
      cmd+=("--subdomain" "$app_subdomain")
    fi
    
    echo "Running: ${cmd[*]}"
    exec "${cmd[@]}"
    ;;
  update)
    ensure_templates
    TEMPLATES_ROOT="$TEMPLATES_ROOT" PROJECT_ROOT_OVERRIDE="$PROJECT_ROOT_OVERRIDE" \
      bash "$TEMPLATES_ROOT/deployment-templates/generators/generate.sh" "$@"
    ;;
  deploy)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    echo "üöÄ Deploying service with vault security..."
    echo "üìÅ Service directory: $svc_dir"
    if [[ ! -d "$svc_dir" ]]; then
      echo "‚ùå Service directory not found: $svc_dir"
      echo "üí° Available services:"
      find "$PROJECT_ROOT_OVERRIDE/deployments" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort || echo "   (none found)"
      exit 1
    fi
    
    # Determine service type
    service_type=""
    if [[ -f "$svc_dir/service-config.yml" ]]; then
      service_type=$(grep -E '^service_type:' "$svc_dir/service-config.yml" | awk -F: '{print $2}' | xargs || true)
    fi
    
    # Ensure vault passwords exist
    echo "üîí Managing secure passwords..."
    ensure_service_passwords "$svc" "$service_type"
    
    echo "üìã Service files:"
    ls -la "$svc_dir" | head -10
    ( cd "$svc_dir" && ./deploy.sh )
    ;;
  redeploy)
    svc="${1:-}"
    shift || true
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    
    # Check if service supports redeployment
    service_type=""
    if [[ -f "$svc_dir/service-config.yml" ]]; then
      service_type=$(grep -E '^service_type:' "$svc_dir/service-config.yml" | awk -F: '{print $2}' | xargs || true)
    fi
    
    if [[ ! "$service_type" =~ ^(nodejs|python|golang|static|signal-api)$ ]]; then
      echo "‚ùå Service type '$service_type' does not support code redeployment"
      echo "   Supported types: nodejs, python, golang, static, signal-api"
      exit 1
    fi
    
    if [[ -f "$svc_dir/redeploy.sh" ]]; then
      echo "üîÑ Redeploying code for service: $svc"
      ( cd "$svc_dir" && ./redeploy.sh "$@" )
    else
      echo "‚ùå No redeploy.sh found for $svc. Please regenerate the service."
      exit 1
    fi
    ;;
  redeploy-all)
    # Redeploy all code-based services
    root_dir="$PROJECT_ROOT_OVERRIDE/deployments"
    if [[ ! -d "$root_dir" ]]; then
      echo "No deployments directory found at: $root_dir"
      exit 0
    fi
    echo "üîÑ Redeploying all code-based services..."
    echo "========================================"
    find "$root_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | grep -v '^\.' | sort | while read -r svc; do
      [[ -z "$svc" ]] && continue
      
      # Check service type
      service_type=""
      if [[ -f "$root_dir/$svc/service-config.yml" ]]; then
        service_type=$(grep -E '^service_type:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
      fi
      
      if [[ "$service_type" =~ ^(nodejs|python|golang|static)$ ]]; then
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "üîÑ Redeploying: $svc ($service_type)"
        if [[ -f "$root_dir/$svc/redeploy.sh" ]]; then
          ( cd "$root_dir/$svc" && ./redeploy.sh "$@" ) || echo "‚ùå Failed to redeploy $svc"
        else
          echo "‚ùå No redeploy.sh found for $svc"
        fi
      else
        echo "‚è≠Ô∏è  Skipping $svc (type: $service_type, not code-based)"
      fi
    done
    ;;
  deploy-all)
    # Deploy all services with vault security
    root_dir="$PROJECT_ROOT_OVERRIDE/deployments"
    if [[ ! -d "$root_dir" ]]; then
      echo "No deployments directory found at: $root_dir"
      exit 0
    fi
    echo "üöÄ Deploying all services with vault security..."
    echo "================================================"
    find "$root_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | grep -v '^\.' | sort | while read -r svc; do
      [[ -z "$svc" ]] && continue
      echo ""
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo "üîÑ Deploying: $svc"
      
      # Determine service type
      service_type=""
      if [[ -f "$root_dir/$svc/service-config.yml" ]]; then
        service_type=$(grep -E '^service_type:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
      fi
      
      # Ensure vault passwords exist
      echo "üîí Managing secure passwords for $svc..."
      ensure_service_passwords "$svc" "$service_type"
      
      if [[ -f "$root_dir/$svc/deploy.sh" ]]; then
        ( cd "$root_dir/$svc" && ./deploy.sh ) || echo "‚ùå Failed to deploy $svc"
      else
        echo "‚ùå No deploy.sh found for $svc"
      fi
    done
    ;;
  cleanup)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    if [[ -f "$svc_dir/cleanup.sh" ]]; then
      echo "üßπ Cleaning up service: $svc"
      ( cd "$svc_dir" && ./cleanup.sh )
    else
      echo "‚ùå No cleanup.sh found for $svc"
      exit 1
    fi
    ;;
  list)
    root_dir="$PROJECT_ROOT_OVERRIDE/deployments"
    if [[ ! -d "$root_dir" ]]; then
      echo "No deployments directory found at: $root_dir"
      exit 0
    fi
    echo "üìã Available Services"
    echo "===================="
    echo ""
    find "$root_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | grep -v '^\.' | sort | while read -r svc; do
      [[ -z "$svc" ]] && continue
      echo "üîπ $svc"
      
      # Read service properties from service-config.yml
      if [[ -f "$root_dir/$svc/service-config.yml" ]]; then
        vm_id=$(grep -E '^vm_id:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
        app_port=$(grep -E '^app_port:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
        service_type=$(grep -E '^service_type:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
        app_subdomain=$(grep -E '^app_subdomain:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
        proxmox_node=$(grep -E '^proxmox_node:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
        
        echo "   Type: ${service_type:-unknown}"
        echo "   VM ID: ${vm_id:-unknown}"
        echo "   Port: ${app_port:-unknown}"
        echo "   Node: ${proxmox_node:-unknown}"
        [[ -n "$app_subdomain" ]] && echo "   Subdomain: $app_subdomain"
      fi
      
      # Proxmox VM status
      pve_status=$(service_status_via_api "$root_dir/$svc")
      [[ -n "$pve_status" ]] && echo "   PVE: $pve_status"

      # Show DNS-based reachability
      fqdn=""
      if [[ -f "$root_dir/$svc/service-config.yml" ]]; then
        service_host=$(grep -E '^service_hostname:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
        # Get dns_domain from global config
        dns_domain=$(grep -E '^dns_domain:' "$root_dir/global-config.yml" | awk -F: '{print $2}' | sed 's/"//g' | xargs || true)
        if [[ -n "$service_host" && -n "$dns_domain" ]]; then
          fqdn="$service_host.$dns_domain"
        fi
      fi
      if [[ -n "$fqdn" ]]; then
        ip_resolved=$(getent hosts "$fqdn" 2>/dev/null | awk '{print $1}' | head -n1 || true)
        if [[ -z "$ip_resolved" ]]; then
          # macOS fallback
          ip_resolved=$(dig +short "$fqdn" 2>/dev/null | head -n1 || true)
        fi
        if [[ -n "$ip_resolved" ]]; then
          echo "   DNS: üü¢ $fqdn ‚Üí $ip_resolved"
        else
          echo "   DNS: ‚ö™ $fqdn (unresolved)"
        fi
      fi
      # API IP (if creds available)
      api_ip=$(service_ip_via_api "$root_dir/$svc")
      [[ -n "$api_ip" ]] && echo "   API IP: $api_ip"
      echo ""
    done
    ;;
  manage)
    # Alias of status for now
    shift || true
    set -- status "$@"
    exec "$0" "$@"
    ;;
  status)
    target_svc="${1:-}"
    root_dir="$PROJECT_ROOT_OVERRIDE/deployments"
    if [[ -z "$target_svc" ]]; then
      # all services
      find "$root_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | grep -v '^\.' | sort | while read -r svc; do
        [[ -z "$svc" ]] && continue
        svc_dir="$root_dir/$svc"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        # Build FQDN
        fqdn="$(service_fqdn "$svc_dir")"
        app_port=""
        [[ -f "$svc_dir/env.service" ]] && { source "$svc_dir/env.service" 2>/dev/null || true; app_port="${APP_PORT:-}"; }
        echo "[${svc}]"
        if [[ -z "$fqdn" ]]; then echo "  FQDN: unknown"; echo ""; continue; fi
        echo "  FQDN: $fqdn"
        api_ip=$(service_ip_via_api "$svc_dir"); [[ -n "$api_ip" ]] && echo "  IP(API): $api_ip"
        ssh_host="$fqdn"; [[ -n "$api_ip" ]] && ssh_host="$api_ip"
        if [[ -n "$ssh_host" ]]; then
          units="$(determine_units "$svc_dir" "$svc")"
          ssh -i "$HOME/.ssh/id_proxmox" -o StrictHostKeyChecking=no -o BatchMode=yes -o ConnectTimeout=5 root@"$ssh_host" "
            for u in $units; do echo \"Service: \$u\"; systemctl is-active \$u || true; done; 
            ss -tlnp | grep :${app_port:-0} || true
          " 2>/dev/null | sed 's/^/  /'
        fi
        echo ""
      done
    else
      svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$target_svc"
      if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $target_svc"; exit 1; fi
      fqdn="$(service_fqdn "$svc_dir")"
      app_port=""
      [[ -f "$svc_dir/env.service" ]] && { source "$svc_dir/env.service" 2>/dev/null || true; app_port="${APP_PORT:-}"; }
      echo "Service: $target_svc"
      echo "FQDN: ${fqdn:-unknown}"
      api_ip=$(service_ip_via_api "$svc_dir"); [[ -n "$api_ip" ]] && echo "IP(API): $api_ip"
      ssh_host="$fqdn"; [[ -n "$api_ip" ]] && ssh_host="$api_ip"
      if [[ -n "$ssh_host" ]]; then
        units="$(determine_units "$svc_dir" "$target_svc")"
        ssh -i "$HOME/.ssh/id_proxmox" -o StrictHostKeyChecking=no -o BatchMode=yes -o ConnectTimeout=5 root@"$ssh_host" "
          echo 'üîç Service units:'; for u in $units; do echo \"- \$u\"; systemctl status \$u --no-pager -n 5 || true; echo ''; done
          echo 'üåê Ports:'; ss -tlnp | grep :${app_port:-0} || true
        "
      fi
    fi
    ;;
  ip)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    ip=$(service_ip_via_api "$svc_dir")
    if [[ -n "$ip" ]]; then echo "$ip"; else echo ""; fi
    ;;
  logs)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    fqdn="$(service_fqdn "$svc_dir")"
    if [[ -z "$fqdn" ]]; then echo "FQDN not found for $svc"; exit 1; fi
    ssh -i "$HOME/.ssh/id_proxmox" -o StrictHostKeyChecking=no root@"$fqdn" "journalctl -u ${svc} --no-pager -n 100"
    ;;
  nodes)
    # List Proxmox nodes using API token
    if [[ -z "${PROXMOX_HOST:-}" || -z "${TOKEN_ID:-}" || -z "${TOKEN_SECRET:-}" ]]; then
      echo "Missing PROXMOX_HOST/TOKEN_ID/TOKEN_SECRET. Export them or source your global config."
      exit 1
    fi
    RESP=$(curl -ks -H "Authorization: PVEAPIToken=${TOKEN_ID}=${TOKEN_SECRET}" \
      "https://${PROXMOX_HOST}:8006/api2/json/nodes")
    if command -v jq >/dev/null 2>&1; then
      echo "$RESP" | jq -r '.data[] | "\(.node)\tstatus=\(.status)\tmem=\(.mem // 0)/\(.maxmem // 0)"'
    else
      echo "$RESP"
    fi
    ;;
  restart)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    fqdn="$(service_fqdn "$svc_dir")"
    if [[ -z "$fqdn" ]]; then echo "FQDN not found for $svc"; exit 1; fi
    ssh -i "$HOME/.ssh/id_proxmox" -o StrictHostKeyChecking=no root@"$fqdn" "systemctl restart ${svc} && systemctl status ${svc} --no-pager -n 5" || exit 1
    ;;
  info)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    [[ -f "$svc_dir/env.service" ]] && source "$svc_dir/env.service" 2>/dev/null || true
    fqdn="$(service_fqdn "$svc_dir")"
    echo "Service: $svc"
    echo "VM ID: ${VM_ID:-unknown}"
    echo "Port: ${APP_PORT:-unknown}"
    echo "FQDN: ${fqdn:-unknown}"
    if [[ -n "$fqdn" ]]; then
      ip_resolved=$(getent hosts "$fqdn" 2>/dev/null | awk '{print $1}' | head -n1 || true)
      [[ -z "$ip_resolved" ]] && ip_resolved=$(dig +short "$fqdn" 2>/dev/null | head -n1 || true)
      [[ -n "$ip_resolved" ]] && echo "IP: $ip_resolved"
      [[ -n "${APP_PORT:-}" ]] && echo "URL: http://$fqdn:${APP_PORT}"
    fi
    ;;
  ssh)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    fqdn="$(service_fqdn "$svc_dir")"
    if [[ -z "$fqdn" ]]; then echo "FQDN not found for $svc"; exit 1; fi
    exec ssh -i "$HOME/.ssh/id_proxmox" root@"$fqdn"
    ;;
  vault-init)
    echo "üîí Initializing vault system..."
    init_vault_system
    ;;
  vault-list)
    init_vault_if_needed
    echo "üîê Encrypted passwords in vault:"
    ansible-vault view "$VAULT_DIR/vault.yml" --vault-password-file "$VAULT_DIR/.vault_password" | python3 -c "
import yaml
import sys
data = yaml.safe_load(sys.stdin)
passwords = data.get('vault_passwords', {})
if passwords:
    for service in sorted(passwords.keys()):
        print(f'  - {service}')
else:
    print('  (no passwords stored)')
"
    ;;
  vault-show)
    svc="${1:-}"
    password_type="${2:-db}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    init_vault_if_needed
    
    password_key="$svc"
    if [[ "$password_type" == "vm_root" ]]; then
      password_key="vm_root_$svc"
    fi
    
    password=$(ansible-vault view "$VAULT_DIR/vault.yml" --vault-password-file "$VAULT_DIR/.vault_password" | python3 -c "
import yaml
import sys
data = yaml.safe_load(sys.stdin)
passwords = data.get('vault_passwords', {})
if '$password_key' in passwords:
    print(passwords['$password_key'])
else:
    sys.exit(1)
" 2>/dev/null)
    
    if [[ $? -eq 0 && -n "$password" ]]; then
      echo "$password"
    else
      echo "‚ùå Password for '$password_key' not found in vault"
      exit 1
    fi
    ;;
  vault-rotate)
    svc="${1:-}"
    password_type="${2:-db}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    init_vault_if_needed
    
    password_key="$svc"
    if [[ "$password_type" == "vm_root" ]]; then
      password_key="vm_root_$svc"
    fi
    
    echo "üîÑ Rotating password for: $password_key"
    
    # Force regenerate by removing existing password first
    temp_file="$VAULT_DIR/.temp_vault_$$_$(date +%s)"
    ansible-vault decrypt "$VAULT_DIR/vault.yml" --vault-password-file "$VAULT_DIR/.vault_password" --output "$temp_file"
    
    python3 << EOF
import yaml
import sys

with open('$temp_file', 'r') as f:
    data = yaml.safe_load(f) or {}

if 'vault_passwords' not in data:
    data['vault_passwords'] = {}

# Remove existing password to force regeneration
if '$password_key' in data['vault_passwords']:
    del data['vault_passwords']['$password_key']

with open('$temp_file', 'w') as f:
    yaml.dump(data, f, default_flow_style=False)
EOF
    
    ansible-vault encrypt "$temp_file" --vault-password-file "$VAULT_DIR/.vault_password" --encrypt-vault-id default
    mv "$temp_file" "$VAULT_DIR/vault.yml"
    
    # Now generate new password
    encrypt_service_password "$svc" "$password_type"
    echo "‚úÖ Password rotated successfully"
    ;;
  vault-backup)
    init_vault_if_needed
    backup_file="vault_backup_$(date +%Y%m%d_%H%M%S).tar.gz"
    tar -czf "$backup_file" -C "$PROJECT_ROOT_OVERRIDE" vault/
    echo "‚úÖ Vault backup created: $backup_file"
    echo "üîí Store this backup securely - it contains encrypted passwords"
    ;;
  help|*)
    usage
    ;;
esac



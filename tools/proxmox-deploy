#!/bin/bash

set -euo pipefail

CMD="${1:-help}"
shift || true

# Check for --remote-templates flag
USE_REMOTE_TEMPLATES=false
if [[ "$CMD" == "--remote-templates" ]]; then
  USE_REMOTE_TEMPLATES=true
  CMD="${1:-help}"
  shift || true
fi

TEMPLATES_ROOT_DEFAULT="$HOME/.proxmox-deploy/templates"
PROJECT_ROOT_OVERRIDE="${PROJECT_ROOT_OVERRIDE:-$(pwd)}"

# Auto-detect if we're running from within the repository for development
detect_local_templates() {
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local repo_root="$(dirname "$script_dir")"
  
  # Check if we're in the proxmox-deploy-playground repository
  if [[ -f "$repo_root/deployment-templates/generators/generate.sh" ]]; then
    echo "$repo_root"
  else
    echo ""
  fi
}

# Determine templates root: use local if in repo, otherwise use default
LOCAL_REPO_ROOT="$(detect_local_templates)"
if [[ -n "$LOCAL_REPO_ROOT" && -z "${TEMPLATES_ROOT:-}" && "$USE_REMOTE_TEMPLATES" == "false" ]]; then
  TEMPLATES_ROOT="$LOCAL_REPO_ROOT"
  echo "ðŸ”§ Using local templates from: $TEMPLATES_ROOT"
  echo "ðŸ“ Template source: Local repository (development mode)"
  echo "   - Base templates: $TEMPLATES_ROOT/deployment-templates/base/"
  echo "   - Service types: $TEMPLATES_ROOT/deployment-templates/service-types/"
  echo "   - Generators: $TEMPLATES_ROOT/deployment-templates/generators/"
else
  TEMPLATES_ROOT="${TEMPLATES_ROOT:-$TEMPLATES_ROOT_DEFAULT}"
  echo "ðŸ“ Template source: Remote/cached templates"
  echo "   - Templates root: $TEMPLATES_ROOT"
fi

# Helper: Auto-discover and load .env files
load_env_files() {
  local loaded_files=()
  
  # 1. Load global CLI environment (~/.pxdcli/env.global) if present
  PXDCLI_CONFIG_DIR="${PXDCLI_CONFIG_DIR:-$HOME/.pxdcli}"
  PXDCLI_GLOBAL_ENV="${PXDCLI_GLOBAL_ENV:-$PXDCLI_CONFIG_DIR/env.global}"
  if [[ -f "$PXDCLI_GLOBAL_ENV" ]]; then
    # shellcheck disable=SC1090
    . "$PXDCLI_GLOBAL_ENV"
    loaded_files+=("$PXDCLI_GLOBAL_ENV")
  fi
  
  # 2. Auto-discover .env files in current directory and parent directories
  local current_dir="$(pwd)"
  local search_dir="$current_dir"
  
  # Search up to 3 levels up for .env files
  for i in {1..3}; do
    if [[ -f "$search_dir/.env" ]]; then
      echo "ðŸ”§ Loading environment from: $search_dir/.env"
      # shellcheck disable=SC1090
      set -a; . "$search_dir/.env"; set +a
      loaded_files+=("$search_dir/.env")
      break  # Stop at first .env file found
    fi
    
    # Move up one directory
    local parent_dir="$(dirname "$search_dir")"
    if [[ "$parent_dir" == "$search_dir" ]]; then
      break  # Reached root directory
    fi
    search_dir="$parent_dir"
  done
  
  # 3. Also check for project-specific .env in the proxmox-deploy root
  if [[ -f "$PROJECT_ROOT_OVERRIDE/.env" && "$PROJECT_ROOT_OVERRIDE/.env" != "$current_dir/.env" ]]; then
    echo "ðŸ”§ Loading project environment from: $PROJECT_ROOT_OVERRIDE/.env"
    # shellcheck disable=SC1090
    set -a; . "$PROJECT_ROOT_OVERRIDE/.env"; set +a
    loaded_files+=("$PROJECT_ROOT_OVERRIDE/.env")
  fi
  
  # Show what was loaded
  if [[ ${#loaded_files[@]} -gt 0 ]]; then
    echo "âœ… Loaded environment from ${#loaded_files[@]} file(s):"
    printf "   - %s\n" "${loaded_files[@]}"
  else
    echo "â„¹ï¸  No .env files found - using shell environment variables"
  fi
}

# Load environment files automatically
load_env_files

ensure_templates() {
  # Skip git operations if using local templates from the repository
  if [[ -n "$LOCAL_REPO_ROOT" && "$TEMPLATES_ROOT" == "$LOCAL_REPO_ROOT" ]]; then
    echo "ðŸ“ Using local repository templates (development mode)"
    return 0
  fi
  
  # Standard behavior: clone or update remote templates
  if [[ ! -d "$TEMPLATES_ROOT/.git" ]]; then
    mkdir -p "$(dirname "$TEMPLATES_ROOT")"
    git clone --depth 1 https://github.com/mkalafior/proxmox-deploy-playground "$TEMPLATES_ROOT"
  else
    git -C "$TEMPLATES_ROOT" pull --ff-only || true
  fi
}

# Helper: extract key from YAML (simple key: value) without yq
yaml_get_key() {
  local file="$1"; shift; local key="$1"; shift
  [[ -f "$file" ]] || { echo ""; return 0; }
  grep -E "^${key}:" "$file" | head -n1 | awk -F: '{print $2}' | xargs || true
}

# Helper: determine FQDN for a service
service_fqdn() {
  local svc_dir="$1"; shift
  local gv="$svc_dir/group_vars/all.yml"
  local host="$(yaml_get_key "$gv" "service_hostname")"
  local domain="$(yaml_get_key "$gv" "dns_domain")"
  if [[ -n "$host" && -n "$domain" ]]; then
    echo "$host.$domain"
  else
    echo ""
  fi
}

# Helper: get VM IP via Proxmox API using node and VM_ID
service_ip_via_api() {
  local svc_dir="$1"; shift
  local gv="$svc_dir/group_vars/all.yml"
  local node="$(yaml_get_key "$gv" "proxmox_node")"
  local vmid=""
  if [[ -f "$svc_dir/env.service" ]]; then
    # shellcheck disable=SC1090
    source "$svc_dir/env.service" 2>/dev/null || true
    vmid="${VM_ID:-}"
  fi
  if [[ -z "${PROXMOX_HOST:-}" || -z "${TOKEN_ID:-}" || -z "${TOKEN_SECRET:-}" || -z "$node" || -z "$vmid" ]]; then
    echo ""; return 0
  fi
  local url="https://${PROXMOX_HOST}:8006/api2/json/nodes/${node}/lxc/${vmid}/interfaces"
  local resp
  resp=$(curl -ks -H "Authorization: PVEAPIToken=${TOKEN_ID}=${TOKEN_SECRET}" "$url" 2>/dev/null || true)
  if command -v jq >/dev/null 2>&1; then
    echo "$resp" | jq -r '(
      .data[]? | select(.name=="eth0") |
      (.inet | if type=="array" then .[0] elif type=="string" then . else "" end)
    ) // ""' | sed 's#/.*$##' | head -n1
  else
    echo "$resp" | grep -o '"name":"eth0"[^{]*\{[^}]*\}' | grep -o '"inet":[^\]]*' | grep -Eo '"[0-9.]+/[0-9]+"' | head -n1 | tr -d '"' | sed 's#/.*$##'
  fi
}

# Helper: get VM status via Proxmox API (running/stopped)
service_status_via_api() {
  local svc_dir="$1"; shift
  local service_config="$svc_dir/service-config.yml"
  
  # Get values from service-config.yml
  local node=""
  local vmid=""
  if [[ -f "$service_config" ]]; then
    node=$(grep -E '^proxmox_node:' "$service_config" | awk -F: '{print $2}' | xargs || true)
    vmid=$(grep -E '^vm_id:' "$service_config" | awk -F: '{print $2}' | xargs || true)
  fi
  
  if [[ -z "${PROXMOX_HOST:-}" || -z "${TOKEN_ID:-}" || -z "${TOKEN_SECRET:-}" || -z "$node" || -z "$vmid" ]]; then
    echo ""; return 0
  fi
  
  local url="https://${PROXMOX_HOST}:8006/api2/json/nodes/${node}/lxc/${vmid}/status/current"
  local resp
  resp=$(curl -ks -H "Authorization: PVEAPIToken=${TOKEN_ID}=${TOKEN_SECRET}" "$url" 2>/dev/null || true)
  if command -v jq >/dev/null 2>&1; then
    echo "$resp" | jq -r '.data.status // empty'
  else
    echo "$resp" | grep -o '"status"\s*:\s*"[^"]\+"' | head -n1 | sed 's/.*:"\(.*\)"/\1/'
  fi
}

# Helper: determine which systemd unit(s) to check for a service
determine_units() {
  local svc_dir="$1"; shift
  local default_unit="$1"; shift || true
  local config_file="$svc_dir/service-config.yml"
  local group_vars_file="$svc_dir/group_vars/all.yml"
  local units=""
  local service_type="$(yaml_get_key "$config_file" "service_type")"
  local app_service_name="$(yaml_get_key "$group_vars_file" "app_service_name")"
  [[ -z "$app_service_name" ]] && app_service_name="$default_unit"

  if [[ "$service_type" == "database" ]]; then
    local db_type="$(yaml_get_key "$config_file" "db_type")"
    [[ -z "$db_type" ]] && db_type="$(yaml_get_key "$config_file" "runtime_variant")"
    case "$db_type" in
      postgresql|postgres)
        units="postgresql"
        ;;
      mysql|mariadb)
        units="mysql"
        ;;
      redis)
        units="redis-server"
        ;;
      mongodb|mongo)
        units="mongod"
        ;;
      *)
        units="postgresql mysql redis-server mongod"
        ;;
    esac
  elif [[ "$service_type" == "tor-proxy" ]]; then
    units="tor privoxy"
  else
    units="$app_service_name"
  fi

  echo "$units"
}

usage() {
  echo "pxdcli [--remote-templates] <command> [args]"
  echo ""
  echo "Options:"
  echo "  --remote-templates                       # Force use of remote templates (skip local detection)"
  echo ""
  echo "Commands:"
  echo "  generate <service> --type <type> [opts]  # Generate service with command-line args"
  echo "  create <service>                         # Interactive service generation"
  echo "  update [options] [services...]           # Update deployment templates"
  echo "    --dry-run                            # Preview changes without applying"
  echo "    --force                              # Force update even if no changes"
  echo "    --no-backup                          # Skip backup creation"
  echo "    --type <type>                        # Update only specific service type"
  echo "    --file <file>                        # Update only specific template file"
  echo "  deploy <service>                         # Deploy single service"
  echo "  deploy-all                               # Deploy all services"
  echo "  redeploy <service> [--no-build] [--force] # Redeploy code for existing service"
  echo "  redeploy-all [--no-build] [--force]     # Redeploy all code-based services"
  echo "  cleanup <service>                        # Cleanup/destroy service"
  echo "  list                                     # List services under PROJECT_ROOT/deployments"
  echo "  status [service]                         # Show service status (hostname-based)"
  echo "  logs <service>                           # Show recent logs via SSH"
  echo "  restart <service>                        # Restart service unit via SSH"
  echo "  info <service>                           # Show service info (FQDN, IP, ports)"
  echo "  ssh <service>                            # SSH into service host"
  echo "  nodes                                    # List Proxmox nodes (requires TOKEN_ID/TOKEN_SECRET)"
  echo "  help"
}

case "$CMD" in
  generate)
    ensure_templates
    TEMPLATES_ROOT="$TEMPLATES_ROOT" PROJECT_ROOT_OVERRIDE="$PROJECT_ROOT_OVERRIDE" \
      bash "$TEMPLATES_ROOT/deployment-templates/generators/generate.sh" "$@"
    ;;
  create)
    # Interactive service generation (migrated from manage-services.sh)
    service_name="${1:-}"
    if [[ -z "$service_name" ]]; then
      echo "Usage: pxdcli create <service-name>"
      exit 1
    fi
    
    if [[ -d "$PROJECT_ROOT_OVERRIDE/deployments/$service_name" ]]; then
      echo "âš ï¸  Service '$service_name' already exists"
      read -p "Overwrite existing service? (y/N): " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Generation cancelled"
        exit 0
      fi
    fi
    
    echo "ðŸš€ Creating new service: $service_name"
    echo "======================================"
    echo ""
    
    # Interactive prompts
    read -p "Application port (e.g., 3003): " app_port
    while [[ ! "$app_port" =~ ^[0-9]+$ ]]; do
      echo "Port must be a number"
      read -p "Application port (e.g., 3003): " app_port
    done
    
    read -p "Cloudflare subdomain (optional, leave blank to disable): " app_subdomain
    read -p "Service hostname (optional, default: $service_name): " service_hostname
    service_hostname=${service_hostname:-$service_name}
    
    read -p "Service type (nodejs/python/golang/rust/database/static/tor-proxy): " service_type
    service_type=$(echo "$service_type" | tr '[:upper:]' '[:lower:]')
    
    runtime_variant=""
    if [[ "$service_type" == "nodejs" ]]; then
      read -p "Node runtime (node/bun) [bun]: " runtime_variant
      runtime_variant=${runtime_variant:-bun}
    elif [[ "$service_type" == "database" ]]; then
      read -p "Database type (postgresql/mysql/redis/mongodb) [postgresql]: " runtime_variant
      runtime_variant=${runtime_variant:-postgresql}
    fi
    
    # Build command
    cmd=("pxdcli" "generate" "$service_name" "--type" "$service_type" "--port" "$app_port" "--hostname" "$service_hostname")
    if [[ -n "$runtime_variant" ]]; then
      cmd+=("--runtime" "$runtime_variant")
    fi
    if [[ -n "$app_subdomain" ]]; then
      cmd+=("--subdomain" "$app_subdomain")
    fi
    
    echo "Running: ${cmd[*]}"
    exec "${cmd[@]}"
    ;;
  update)
    ensure_templates
    TEMPLATES_ROOT="$TEMPLATES_ROOT" PROJECT_ROOT_OVERRIDE="$PROJECT_ROOT_OVERRIDE" \
      bash "$TEMPLATES_ROOT/deployment-templates/generators/generate.sh" "$@"
    ;;
  deploy)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    echo "ðŸš€ Deploying service..."
    echo "ðŸ“ Service directory: $svc_dir"
    if [[ ! -d "$svc_dir" ]]; then
      echo "âŒ Service directory not found: $svc_dir"
      echo "ðŸ’¡ Available services:"
      find "$PROJECT_ROOT_OVERRIDE/deployments" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort || echo "   (none found)"
      exit 1
    fi
    echo "ðŸ“‹ Service files:"
    ls -la "$svc_dir" | head -10
    ( cd "$svc_dir" && ./deploy.sh )
    ;;
  redeploy)
    svc="${1:-}"
    shift || true
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    
    # Check if service supports redeployment
    service_type=""
    if [[ -f "$svc_dir/group_vars/all.yml" ]]; then
      service_type=$(grep -E '^service_type:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
    fi
    
    if [[ ! "$service_type" =~ ^(nodejs|python|golang|static)$ ]]; then
      echo "âŒ Service type '$service_type' does not support code redeployment"
      echo "   Supported types: nodejs, python, golang, static"
      exit 1
    fi
    
    if [[ -f "$svc_dir/redeploy.sh" ]]; then
      echo "ðŸ”„ Redeploying code for service: $svc"
      ( cd "$svc_dir" && ./redeploy.sh "$@" )
    else
      echo "âŒ No redeploy.sh found for $svc. Please regenerate the service."
      exit 1
    fi
    ;;
  redeploy-all)
    # Redeploy all code-based services
    root_dir="$PROJECT_ROOT_OVERRIDE/deployments"
    if [[ ! -d "$root_dir" ]]; then
      echo "No deployments directory found at: $root_dir"
      exit 0
    fi
    echo "ðŸ”„ Redeploying all code-based services..."
    echo "========================================"
    find "$root_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort | while read -r svc; do
      [[ -z "$svc" ]] && continue
      
      # Check service type
      service_type=""
      if [[ -f "$root_dir/$svc/group_vars/all.yml" ]]; then
        service_type=$(grep -E '^service_type:' "$root_dir/$svc/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
      fi
      
      if [[ "$service_type" =~ ^(nodejs|python|golang|static)$ ]]; then
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ðŸ”„ Redeploying: $svc ($service_type)"
        if [[ -f "$root_dir/$svc/redeploy.sh" ]]; then
          ( cd "$root_dir/$svc" && ./redeploy.sh "$@" ) || echo "âŒ Failed to redeploy $svc"
        else
          echo "âŒ No redeploy.sh found for $svc"
        fi
      else
        echo "â­ï¸  Skipping $svc (type: $service_type, not code-based)"
      fi
    done
    ;;
  deploy-all)
    # Deploy all services
    root_dir="$PROJECT_ROOT_OVERRIDE/deployments"
    if [[ ! -d "$root_dir" ]]; then
      echo "No deployments directory found at: $root_dir"
      exit 0
    fi
    echo "ðŸš€ Deploying all services..."
    echo "============================"
    find "$root_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort | while read -r svc; do
      [[ -z "$svc" ]] && continue
      echo ""
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo "ðŸ”„ Deploying: $svc"
      if [[ -f "$root_dir/$svc/deploy.sh" ]]; then
        ( cd "$root_dir/$svc" && ./deploy.sh ) || echo "âŒ Failed to deploy $svc"
      else
        echo "âŒ No deploy.sh found for $svc"
      fi
    done
    ;;
  cleanup)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    if [[ -f "$svc_dir/cleanup.sh" ]]; then
      echo "ðŸ§¹ Cleaning up service: $svc"
      ( cd "$svc_dir" && ./cleanup.sh )
    else
      echo "âŒ No cleanup.sh found for $svc"
      exit 1
    fi
    ;;
  list)
    root_dir="$PROJECT_ROOT_OVERRIDE/deployments"
    if [[ ! -d "$root_dir" ]]; then
      echo "No deployments directory found at: $root_dir"
      exit 0
    fi
    echo "ðŸ“‹ Available Services"
    echo "===================="
    echo ""
    find "$root_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort | while read -r svc; do
      [[ -z "$svc" ]] && continue
      echo "ðŸ”¹ $svc"
      
      # Read service properties from service-config.yml
      if [[ -f "$root_dir/$svc/service-config.yml" ]]; then
        vm_id=$(grep -E '^vm_id:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
        app_port=$(grep -E '^app_port:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
        service_type=$(grep -E '^service_type:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
        app_subdomain=$(grep -E '^app_subdomain:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
        proxmox_node=$(grep -E '^proxmox_node:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
        
        echo "   Type: ${service_type:-unknown}"
        echo "   VM ID: ${vm_id:-unknown}"
        echo "   Port: ${app_port:-unknown}"
        echo "   Node: ${proxmox_node:-unknown}"
        [[ -n "$app_subdomain" ]] && echo "   Subdomain: $app_subdomain"
      fi
      
      # Proxmox VM status
      pve_status=$(service_status_via_api "$root_dir/$svc")
      [[ -n "$pve_status" ]] && echo "   PVE: $pve_status"

      # Show DNS-based reachability
      fqdn=""
      if [[ -f "$root_dir/$svc/service-config.yml" ]]; then
        service_host=$(grep -E '^service_hostname:' "$root_dir/$svc/service-config.yml" | awk -F: '{print $2}' | xargs || true)
        # Get dns_domain from global config
        dns_domain=$(grep -E '^dns_domain:' "$root_dir/global-config.yml" | awk -F: '{print $2}' | sed 's/"//g' | xargs || true)
        if [[ -n "$service_host" && -n "$dns_domain" ]]; then
          fqdn="$service_host.$dns_domain"
        fi
      fi
      if [[ -n "$fqdn" ]]; then
        ip_resolved=$(getent hosts "$fqdn" 2>/dev/null | awk '{print $1}' | head -n1 || true)
        if [[ -z "$ip_resolved" ]]; then
          # macOS fallback
          ip_resolved=$(dig +short "$fqdn" 2>/dev/null | head -n1 || true)
        fi
        if [[ -n "$ip_resolved" ]]; then
          echo "   DNS: ðŸŸ¢ $fqdn â†’ $ip_resolved"
        else
          echo "   DNS: âšª $fqdn (unresolved)"
        fi
      fi
      # API IP (if creds available)
      api_ip=$(service_ip_via_api "$root_dir/$svc")
      [[ -n "$api_ip" ]] && echo "   API IP: $api_ip"
      echo ""
    done
    ;;
  manage)
    # Alias of status for now
    shift || true
    set -- status "$@"
    exec "$0" "$@"
    ;;
  status)
    target_svc="${1:-}"
    root_dir="$PROJECT_ROOT_OVERRIDE/deployments"
    if [[ -z "$target_svc" ]]; then
      # all services
      find "$root_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort | while read -r svc; do
        [[ -z "$svc" ]] && continue
        svc_dir="$root_dir/$svc"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        # Build FQDN
        fqdn=""
        app_port=""
        [[ -f "$svc_dir/env.service" ]] && { source "$svc_dir/env.service" 2>/dev/null || true; app_port="${APP_PORT:-}"; }
        if [[ -f "$svc_dir/group_vars/all.yml" ]]; then
          service_host=$(grep -E '^service_hostname:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
          dns_domain=$(grep -E '^dns_domain:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
          if [[ -n "$service_host" && -n "$dns_domain" ]]; then fqdn="$service_host.$dns_domain"; fi
        fi
        echo "[${svc}]"
        if [[ -z "$fqdn" ]]; then echo "  FQDN: unknown"; echo ""; continue; fi
        echo "  FQDN: $fqdn"
        api_ip=$(service_ip_via_api "$svc_dir"); [[ -n "$api_ip" ]] && echo "  IP(API): $api_ip"
        ssh_host="$fqdn"; [[ -n "$api_ip" ]] && ssh_host="$api_ip"
        if [[ -n "$ssh_host" ]]; then
          units="$(determine_units "$svc_dir" "$svc")"
          ssh -i "$HOME/.ssh/id_proxmox" -o StrictHostKeyChecking=no -o BatchMode=yes -o ConnectTimeout=5 root@"$ssh_host" "
            for u in $units; do echo \"Service: \$u\"; systemctl is-active \$u || true; done; 
            ss -tlnp | grep :${app_port:-0} || true
          " 2>/dev/null | sed 's/^/  /'
        fi
        echo ""
      done
    else
      svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$target_svc"
      if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $target_svc"; exit 1; fi
      fqdn=""; app_port=""
      [[ -f "$svc_dir/env.service" ]] && { source "$svc_dir/env.service" 2>/dev/null || true; app_port="${APP_PORT:-}"; }
      if [[ -f "$svc_dir/group_vars/all.yml" ]]; then
        service_host=$(grep -E '^service_hostname:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
        dns_domain=$(grep -E '^dns_domain:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
        if [[ -n "$service_host" && -n "$dns_domain" ]]; then fqdn="$service_host.$dns_domain"; fi
      fi
      echo "Service: $target_svc"
      echo "FQDN: ${fqdn:-unknown}"
      api_ip=$(service_ip_via_api "$svc_dir"); [[ -n "$api_ip" ]] && echo "IP(API): $api_ip"
      ssh_host="$fqdn"; [[ -n "$api_ip" ]] && ssh_host="$api_ip"
      if [[ -n "$ssh_host" ]]; then
        units="$(determine_units "$svc_dir" "$target_svc")"
        ssh -i "$HOME/.ssh/id_proxmox" -o StrictHostKeyChecking=no -o BatchMode=yes -o ConnectTimeout=5 root@"$ssh_host" "
          echo 'ðŸ” Service units:'; for u in $units; do echo \"- \$u\"; systemctl status \$u --no-pager -n 5 || true; echo ''; done
          echo 'ðŸŒ Ports:'; ss -tlnp | grep :${app_port:-0} || true
        "
      fi
    fi
    ;;
  ip)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    ip=$(service_ip_via_api "$svc_dir")
    if [[ -n "$ip" ]]; then echo "$ip"; else echo ""; fi
    ;;
  logs)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    fqdn=""; [[ -f "$svc_dir/group_vars/all.yml" ]] && {
      service_host=$(grep -E '^service_hostname:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
      dns_domain=$(grep -E '^dns_domain:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
      [[ -n "$service_host" && -n "$dns_domain" ]] && fqdn="$service_host.$dns_domain";
    }
    if [[ -z "$fqdn" ]]; then echo "FQDN not found for $svc"; exit 1; fi
    ssh -i "$HOME/.ssh/id_proxmox" -o StrictHostKeyChecking=no root@"$fqdn" "journalctl -u ${svc} --no-pager -n 100"
    ;;
  nodes)
    # List Proxmox nodes using API token
    if [[ -z "${PROXMOX_HOST:-}" || -z "${TOKEN_ID:-}" || -z "${TOKEN_SECRET:-}" ]]; then
      echo "Missing PROXMOX_HOST/TOKEN_ID/TOKEN_SECRET. Export them or source your global config."
      exit 1
    fi
    RESP=$(curl -ks -H "Authorization: PVEAPIToken=${TOKEN_ID}=${TOKEN_SECRET}" \
      "https://${PROXMOX_HOST}:8006/api2/json/nodes")
    if command -v jq >/dev/null 2>&1; then
      echo "$RESP" | jq -r '.data[] | "\(.node)\tstatus=\(.status)\tmem=\(.mem // 0)/\(.maxmem // 0)"'
    else
      echo "$RESP"
    fi
    ;;
  restart)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    fqdn=""; [[ -f "$svc_dir/group_vars/all.yml" ]] && {
      service_host=$(grep -E '^service_hostname:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
      dns_domain=$(grep -E '^dns_domain:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
      [[ -n "$service_host" && -n "$dns_domain" ]] && fqdn="$service_host.$dns_domain";
    }
    if [[ -z "$fqdn" ]]; then echo "FQDN not found for $svc"; exit 1; fi
    ssh -i "$HOME/.ssh/id_proxmox" -o StrictHostKeyChecking=no root@"$fqdn" "systemctl restart ${svc} && systemctl status ${svc} --no-pager -n 5" || exit 1
    ;;
  info)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    [[ -f "$svc_dir/env.service" ]] && source "$svc_dir/env.service" 2>/dev/null || true
    fqdn=""; [[ -f "$svc_dir/group_vars/all.yml" ]] && {
      service_host=$(grep -E '^service_hostname:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
      dns_domain=$(grep -E '^dns_domain:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
      [[ -n "$service_host" && -n "$dns_domain" ]] && fqdn="$service_host.$dns_domain";
    }
    echo "Service: $svc"
    echo "VM ID: ${VM_ID:-unknown}"
    echo "Port: ${APP_PORT:-unknown}"
    echo "FQDN: ${fqdn:-unknown}"
    if [[ -n "$fqdn" ]]; then
      ip_resolved=$(getent hosts "$fqdn" 2>/dev/null | awk '{print $1}' | head -n1 || true)
      [[ -z "$ip_resolved" ]] && ip_resolved=$(dig +short "$fqdn" 2>/dev/null | head -n1 || true)
      [[ -n "$ip_resolved" ]] && echo "IP: $ip_resolved"
      [[ -n "${APP_PORT:-}" ]] && echo "URL: http://$fqdn:${APP_PORT}"
    fi
    ;;
  ssh)
    svc="${1:-}"
    if [[ -z "$svc" ]]; then echo "Missing service name"; exit 1; fi
    svc_dir="$PROJECT_ROOT_OVERRIDE/deployments/$svc"
    if [[ ! -d "$svc_dir" ]]; then echo "Service not found: $svc"; exit 1; fi
    fqdn=""; [[ -f "$svc_dir/group_vars/all.yml" ]] && {
      service_host=$(grep -E '^service_hostname:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
      dns_domain=$(grep -E '^dns_domain:' "$svc_dir/group_vars/all.yml" | awk -F: '{print $2}' | xargs || true)
      [[ -n "$service_host" && -n "$dns_domain" ]] && fqdn="$service_host.$dns_domain";
    }
    if [[ -z "$fqdn" ]]; then echo "FQDN not found for $svc"; exit 1; fi
    exec ssh -i "$HOME/.ssh/id_proxmox" root@"$fqdn"
    ;;
  help|*)
    usage
    ;;
esac


